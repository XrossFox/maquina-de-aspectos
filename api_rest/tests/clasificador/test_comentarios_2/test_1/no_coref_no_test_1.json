["@luqui i mean that your code could look more like the python code. you don't need all the readioref and writeioref, they can be done implicitly.", "would it be possible to create something with template haskell that sort of gives you a map literal? i'm not that familiar with how haskell macros work so forgive me if that's a dumb question.", "also, check out the haskell wiki's page on pronunciation. it's incomplete, but relevant.", "function composition. code_removed", "@christianconkle yes, i could.", "code_removed is a data constructor that contains a value. wouldn't it be more accurate to say \"code_removed is a data constructor that itself represents a single value whose concrete type is inferred eventually depending on the context\"? that is to say code_removed can represent exactly one value, but this value can be of different type. this is probably nit-picking - i'm just learning.", "for historical reasons, any haskell data type (including code_removed) must have at least one constructor. hence, to define the code_removed in \"haskell98\" one needs to rely on type-level recursion code_removed. there is no (non-bottom) value of this type. the code_removed function has to rely on (value level) recursion to cope with the \"weird\" form of the code_removed type. in more modern haskell, with some ghc extensions, we can define a zero constructor data type, which would lead to a saner definition. code_removed the case is exhaustive -- it does handle all the constructors of code_removed, all zero of them. hence it is total. in some other functional languages, like agda or coq, a variant of the case above is idiomatic when dealing with empty types like code_removed.", "\"applicative is almost the same as monads, except that effects cannot depend on previous results.\"... a lot of stuff clicked into place for me with this line, thanks!", "or, pointlessly, code_removed", "from the haskell wiki: haskell has a diverse range of use commercially, from aerospace and defense, to finance, to web startups, hardware design firms and lawnmower manufacturers. this page collects resources on the industrial use of haskell. according to wikipedia, the haskell language was created out of the need to consolidate existing functional languages into a common one which could be used for future research in functional-language design. it is apparent based on the information available that it has outgrown it's original purpose and is used for much more than research. it is now considered a general purpose functional programming language. if you're still asking yourself, \"why should i use it?\", then read the why use it? section of the haskell wiki introduction.", "this works because of operator precedence. the function application operator, juxtaposition or code_removed (the space), has the highest precedence, so code_removed parses as code_removed, which is equivalent to code_removed; since function application is left-associative, this is then equivalent to code_removed. in general, any binary operator can be given a precedence with a fixity declaration, such as code_removed the code_removed or code_removed says whether the operation is left- or right-associative (that is, whether code_removed groups as code_removed or code_removed); the number\u2014an integer between 0 and 9\u2014specifies the precedence level. higher numbers mean higher precedence (with application having an effective precedence of \u221e); for instance, code_removed and code_removed have precedence 7, and code_removed and code_removed have precedence 6. to check the precedence of an operator in ghci, just type code_removed (or whichever operator) at the prompt. and just as a note: your code will work, but it's not how i would typically write it. if you're curious, in haskell, i would write that code with the code_removed operator, which just performs function application but is low precedence: code_removed. if i had more functions to apply, i would use the composition operator: code_removed. it reads the other way, but it's what you typically find in haskell.", "i've been gradually learning haskell, and even feel like i've got a hang of monads. however, there's still a lot of more exotic stuff that i barely understand, like arrows, applicative, etc. although i'm picking up bits and pieces from haskell code i've seen, it would be good to find a tutorial that really explains them wholly. (there seem to be dozens of tutorials on monads.. but everything seems to finish straight after that!)", "see also: data.memougly", "i just started a new haskell project and wanted to set up a good testing workflow from the beginning. it seems like haskell has a lot of excellent and unique testing tools and many different ways to integrate them. i have looked into: hunit quickcheck benchpress hpc complexity which all seem to work very well in their domains, but i'm looking for a comprehensive approach to testing and was wondering what has worked well for other people.", "@ankur if you must, parallel list comprehension is cleaner to read because you can avoid constructing and destructing a tuple. code_removed", "thanks for the great write-up. i'd love to see some examples of dependently typed code where some data originates outside the program (e.g. read from a file), to get a feel for how promoting values to types would look like in such a setting. i have this feeling that all examples involve vectors (implemented as lists) with statically known sizes.", "regarding type classes: code_removed is actually simpler than code_removed. i've recently said a few things about it elsewhere, but the gist is that it's about enhanced code_removeds that you can lift functions into. to get a feel for code_removed, you could try writing something using parsec without using code_removed notation--my experience has been that applicative style works better than monadic for straightforward parsers. code_removeds are a very abstract way of working with things that are sort of like functions (\"arrows\" between types). they can be difficult to get your mind around until you stumble on something that's naturally code_removed-like. at one point i reinvented half of code_removed (poorly) while writing interactive state machines with feedback loops. you didn't mention it, but an oft-underrated, powerful type class is the humble code_removed. there are lots of places where monoid-like structure can be found. take a look at the monoids package, for instance. aside from type classes, i'd offer a very simple answer to your question: write programs! the best way to learn is by doing, so pick something fun or useful and just make it happen. in fact, many of the more abstract concepts--like code_removed--will probably make more sense if you come back to them later and find that, like me, they offer a tidy solution to a problem you've encountered but hadn't even realized could be abstracted out. however, if you want something specific to shoot for, why not take a look at functional reactive programming--this is a family of techniques that have a lot of promise, but there are a lot of open questions of what the best way to do it is.", "@marek \"i just thought that side effects are possible only in monads\" -- the connection is much looser than that: (1) the code_removed type can be used to express side effects; (2) code_removed happens to be a monad, which turns out to be very convenient. monads are not essentially linked to side effects. it should also be noted that there is a meaning of \"effect\" which is broader than \"side effect\" in its usual sense -- one which include pure computations. on this last point, see also what exactly does \u201ceffectful\u201d mean.", "by that definition, addition is a higher-order function. it takes a number and returns a function that adds that number to another. so no, higher order functions are strictly functions whose domain consists of functions.", "random-fu just kicks the shuffling down to random-shuffle's code_removed which is, to be honest, a muuuch better shuffling algorithm than i have above. there's also code_removed which ties into the code_removed random functionality directly.", "the code_removed package provides recursive directory traversals, which you might be able to use to simplify your code.", "the article the essence of the iterator pattern might be helpful as it builds the notion of traverse step by step. some advanced concepts are present though", "it's kind of like code_removed, except that you can run effects inside the mapper function, which also changes the result type. imagine a list of integers representing user ids in a database: code_removed. if you want to code_removed these user ids to usernames, you can't use a traditional code_removed, because inside the function you need to access the database to read the usernames (which requires an effect -- in this case, using the code_removed monad). the signature of code_removed is: code_removed with code_removed, you can do effects, therefore, your code for mapping user ids to usernames looks like: code_removed there's also a function called code_removed: code_removed any use of code_removed can be replaced with code_removed, but not the other way around. code_removed only works for monads, whereas code_removed is more generic. if you just want to achieve an effect and not return any useful value, there are code_removed and code_removed versions of these functions, both of which ignore the return value from the function and are slightly faster.", "you may also want to take a look at the ghc guide to using a more precise version of code_removed with safe haskell: ghc.haskell.org/trac/ghc/wiki/safehaskell/\u2026", "@caffeine - at first it seems like a lot of work but you would be surprised at how awesome it is to have largely separate programs sending messages.", "the reason code_removed has the type code_removed is to provide parallel composition with its code_removed instance, next to the sequential composition that the code_removed instance of code_removed provides.", "the dual nature of friendly competition and mix-and-match in haskell web development seems very promising. that said, i'd recommend getting snap-auth over to hackage asap. sessions and authentication are a big deal.", "possible duplicate of how to define a function in ghci across multiple lines?", "\"this is the same for any library function you call. you have no control over what data.list.groupby will do.\" unless code_removed is used, code_removed is limited to returning a list of lists. template haskell isn't.", "@fuzxxl ensuring that things are evaluated without delay can often reduce space usage and make computations much faster. it can also have the reverse effect, so lazy structures are important too. for efficient code, you need both (and have to know/find out which to use where).", "@drozzy: see update.", "i don't believe in solving a more general problem than the asker asked for. there's no limit to how much more complicated you can make a task, so that way lies madness. just solve the task in front of you. there's no indication here that the op wanted to seek or open the file with special modes or open more than one file. code_removed is a very convenient every-day sort of function, and i often see people roll their own convoluted code to read files, perhaps because they are accustomed to languages that do not provide a single-function equivalent to code_removed.", "consider the following type: code_removed we can easily make that type an instance of functor with the following code: code_removed however, if instead the params of the code_removed type were swapped: code_removed then the above instance definition doesn't work. is there some way of making code_removed an instance of functor? if not, are there any up and coming additions to haskell/ghc that would make it possible?", "yes, code_removed is an instance of code_removed. but that doesn't allow using a string as an abritary code_removed value. code_removed can be code_removed because there's an code_removed, an code_removed, an code_removed, etc. if code_removed could be of type code_removed, there would be code_removed, code_removed, code_removed, etc. there isn't. therfore, code_removed can't be of type code_removed. the type of a string constant doesn't get much more general than code_removed.", "@ganeshsittampalam here is my implementation. i don't seem to have a problem with maybe implementing ifunctor. works great in production.", "note that some organizations/standards strongly discourage the use of \"show\" because of its extreme polymorphism. a type-specific function (or, worst case, wrapper around show) would be helpful.", "@willness -- this is a catch 22. i claim the question is not too broad because it lends itself to a relatively succinct answer. but you claim that it cannot be answered by a relatively succinct answer. i would respond, that just because you cannot imagine such an answer does not mean that this answer does not exist. it just means you might learn something from it. which is the point of stack overflow, i thought.", "could you un-accept my answer? it's clearly wrong, though it was the first explanation that came to my mind, so i want to delete it (cannot if it is accepted...). i did some testing and i can reproduce leftaroundabout behaviour: ghc 7.8 doesn't segfault. you should provide specific details about the versions of ghc you are using. also if you can try to install a different ghc versions and see if that segfaults too.", "@joachimbreitner just finished doing that. had to learn template haskell. still testing my answer, but it seems a lot faster (similar to the other question).", "@sargeborsch that cython version is so fast, because it compiles down to a highly optimised c source, which means you sure can get that performance out of c.", "this is an idiom i see pretty often since haskell lacks a proper syntax for a case without matching. to make my intentions clearer, i usually intentionally match code_removed: code_removed", "i believe tuples in python are mutable (i may be wrong). this makes a python tuple behave as a \"reference cell\", where this does not apply to haskell because everything is immutable.", "@monadic: code_removed is in the code_removed class because of a historical accident; it really belongs in code_removed. take note that its default definition is unsafe.", "well, that is indeed not easy. thank you anyway, this is the best answer regarding monad i have ever read:)", "it stops at code_removed", "@thomaseding i'm really late to the party, but i just want to clarify this: code_removed is not an action \u2013 it is a function that returns an action. code_removed is a variable that contains an action. actions are the values, variables and functions are the \"containers\"/\"labels\" we give those actions.", "@pigworker you claim that code_removed is not code_removed and hence this is a bad code_removed instance, but none of the code_removed laws seems to be of that form. (all the equations with one instance of code_removed on some side also have code_removed on that side, according to this list.) what makes you think this wacky expression ought to evaluate to code_removed?", "there's been some discussions on a type level debugger, but the general consensus seems to be showing the internal logic of the typechecker isn't going to help:/ as of right now haskell's constraint solver is a crappy opaque logic language:)", "@\u0434\u043c\u0438\u0442\u0440\u0438\u0439\u043c\u0430\u043b\u0438\u043a\u043e\u0432 why is that?", "looks like a homework or something. better to add your approach and ask the community for ways to improve it instead of just asking the answer.", "note that you can convert any type implementing the code_removed type class to a string using code_removed: code_removed because code_removed implements this, the function is already written for you!", "syntactically i like this one best: code_removed", "@kaizer.se you can think of a global code_removed object that is passed into the program when it starts.", "any program without io is useless...", "it's because code_removed is interpreted as the code_removed operator in the code_removed module. code_removed it means ghc cannot find a module named code_removed. the same message appears if you use a qualified name with a non-existing library: code_removed code_removed in haskell, a section is an infix operator with a partial application, e.g. code_removed, which is equivalent to code_removed. in your case, code_removed is interpreted as an infix code_removed operator, and the code_removed is part of the section formed with this operator. a section must be enclosed in parenthesis, and since the misinterpretation does not, the parser will complain like this. another example of the error: code_removed", "as of today, shelly's cp_r is buggy.code_removed loops see, github.com/yesodweb/shelly.hs/issues/154", "i said that in ghc it works. maybe in any other haskell compiler it is parsed as i said.", "i would mention another post by gabriel gonzalez on the category design pattern. his basic argument is that what we functional programmers think of as \"good architecture\" is really \"compositional architecture\" - it's designing programs using items that are guaranteed to compose. since the category laws guarantee that identity and associativity are preserved under composition, a compositional architecture is achieved through using abstractions for which we have a category - e.g. pure functions, monadic actions, pipes, etc.", "@benmillwood other solutions, what?", "@dylan, i believe paul j. was referring to \"haskell's overlooked object system\", which one can reach here from arxiv.org.", "good question. we haven't looked at that situation yet, but i would expect that in such a case, we should apply the setting to the partial signature. anyway, the current plan is to first see if there is sufficient interest in this feature amongst the ghc developers before doing the effort to look at this kind of issues. (possible) interactions with other features like scopedtypevariables, rankntypes, constraintkinds also remain to be investigated, for example...", "-1 for recommending lyah, which is one of the worst resources out there: too verbose, regularly confusing beginners, and no exercises whatsoever. realworldhaskell is extremely outdated as well. common consensus in the #haskell channel is this link github.com/bitemyapp/learnhaskell", "list is an instance of monad. >>= for lists concatenates.", "this doesn't prove you can't turn off laziness - it only proves that the set of programs where you can turn off laziness and still have them work is heavily constrained. code_removed is just a particularly obvious problem function - there are many less obvious ones that would cause similar problems - but a sufficiently obsessive person might be able to identify and work with a haskell subset that still works with laziness disabled. +1 anyway - that's still a good point.", "what is the meaning of \"what is the meaning of exceptions?\" are you asking about why anyone would ever want to use exceptions, how they should be used, or something else?", "@emre sevin\u00e7 when you have a tuple of numbers, it is often the case that they are semantically different, even if the types are equal... some integer paired with the number of times it appears somewhere, for example. if the numbers are semantically equal, they should better be in a \"uniform\" container like a list or a vector.", "intuitively, i think that what the fancy math vocabulary is saying is that: monoid a monoid is a set of objects, and a method of combining them. well known monoids are: numbers you can add lists you can concatenate sets you can union there are more complex examples also. further, every monoid has an identity, which is that \"no-op\" element that has no effect when you combine it with something else: 0 + 7 == 7 + 0 == 7 [] ++ [1,2,3] == [1,2,3] ++ [] == [1,2,3] {} union {apple} == {apple} union {} == {apple} finally, a monoid must be associative. (you can reduce a long string of combinations anyway you want, as long as you don't change the left-to-right-order of objects) addition is ok ((5+3)+1 == 5+(3+1)), but subtraction isn't ((5-3)-1!= 5-(3-1)). monad now, let's consider a special kind of set and a special way of combining objects. objects suppose your set contains objects of a special kind: functions. and these functions have an interesting signature: they don't carry numbers to numbers or strings to strings. instead, each function carries a number to a list of numbers in a two-step process. compute 0 or more results combine those results unto a single answer somehow. examples: 1 -> [1] (just wrap the input) 1 -> [] (discard the input, wrap the nothingness in a list) 1 -> [2] (add 1 to the input, and wrap the result) 3 -> [4, 6] (add 1 to input, and multiply input by 2, and wrap the multiple results) combining objects also, our way of combining functions is special. a simple way to combine function is composition: let's take our examples above, and compose each function with itself: 1 -> [1] -> [[1]] (wrap the input, twice) 1 -> [] -> [] (discard the input, wrap the nothingness in a list, twice) 1 -> [2] -> [ uh-oh! ] (we can't \"add 1\" to a list!\") 3 -> [4, 6] -> [ uh-oh! ] (we can't add 1 a list!) without getting too much into type theory, the point is that you can combine two integers to get an integer, but you can't always compose two functions and get a function of the same type. (functions with type a -> a will compose, but a-> [a] won't.) so, let's define a different way of combining functions. when we combine two of these functions, we don't want to \"double-wrap\" the results. here is what we do. when we want to combine two functions f and g, we follow this process (called binding): compute the \"results\" from f but don't combine them. compute the results from applying g to each of f's results separately, yielding a collection of collection of results. flatten the 2-level collection and combine all the results. back to our examples, let's combine (bind) a function with itself using this new way of \"binding\" functions: 1 -> [1] -> [1] (wrap the input, twice) 1 -> [] -> [] (discard the input, wrap the nothingness in a list, twice) 1 -> [2] -> [3] (add 1, then add 1 again, and wrap the result.) 3 -> [4,6] -> [5,8,7,12] (add 1 to input, and also multiply input by 2, keeping both results, then do it all again to both results, and then wrap the final results in a list.) this more sophisticated way of combining functions is associative (following from how function composition is associative when you aren't doing the fancy wrapping stuff). tying it all together, a monad is a structure that defines a way to combine (the results of) functions, analogously to how a monoid is a structure that defines a way to combine objects, where the method of combination is associative, and where there is a special 'no-op' that can be combined with any something to result in something unchanged. notes there are lots of ways to \"wrap\" results. you can make a list, or a set, or discard all but the first result while noting if there are no results, attach a sidecar of state, print a log message, etc, etc. i've played a bit loose with the definitions in hopes of getting the essential idea across intuitively. i've simplified things a bit by insisting that our monad operates on functions of type a -> [a]. in fact, monads work on functions of type a -> m b, but the generalization is kind of a technical detail that isn't the main insight.", "getting a lot of support from folks on reddit does not make this question on-topic. this question is overly broad and even though there might be a factual answer to it, it will do nothing but solicit opinions.", "because i find the question interesting, i decided to write down my thoughts on the subject: logical say we define code_removed as \"the list, that, if you put code_removed on its end, is equal to xs. this is equivalent to: code_removed is the list without its last element. for code_removed, there exists no last element, so code_removed has to be undefined. you could add a special case for this, like in \"if xs is the empty list, then code_removed is the empty list, otherwise code_removed is the list, that, if you put code_removed on its end, is equal to xs\". notice how this is much more verbose and less clean. we introduce additional complexity, but what for? intuitive code_removed note how the length of the lists on the right-hand side of the equations decreases along with the length of the left-hand side. to me, this series cannot be continued in a sensible way, because the list on the right side would have to have a negative size! practical as others have pointed out, defining a special case handling for code_removed or code_removed for the empty list as an argument, can introduce hard-to-spot errors in situations where functions can have no sensible result for the empty list, but still don't produce an exception for it! furthermore, i can think of no algorithm were it would actually be of advantage to have code_removed evaluate to code_removed, so why introduce that extra complexity? programming is all about simplicity and especially haskell is all about purity, wouldn't you agree?", "some good places to start are: the gentle introduction to haskell problem solving in haskell happy learn haskell tutorial other resources: interesting blog entry on a study plan for haskell via the wayback machine haskellwiki generic haskell user guide (pdf)", "nice addition to the accepted answer. taken together the two are exactly what i needed to know.", "so, coalgebras seem to fit as a better, first-class substitute of haskell modules, so that we can construct various coalgebras satisfying an interface (= a signature, or better -- a \"cosignature\"? since a \"signature\" is what an algebra has) and pass them as parameters to functions which depend the particular interface of a module that wish to use...", "the two haskell web frameworks in the news recently are yesod (at 0.8) and snap (at 0.4). it's quite obvious that yesod currently supports a lot more features than snap. however, i can't stand the syntax yesod uses for its html, css and javascript. so, i'd like to understand what i'd be missing if i went with snap instead. for example, doesn't look like database support is there. how about sessions? other features?", "@dietrichepp hello, 5 years have passed and now cofunctor is deprecated. also, according to this mo question, functor is self-dual, so it will be misleading to call contravariant functor cofunctor. please update the answer, because it is so great for beginners like me!", "but now i want to choose one ... then i want to know the pros and cons of this powerfull language(just to make the correct choice). if you will permit me to generalize, the choice of a language really depends on the problem you are trying to solve. there is no one choice that will work for everything, and there will always be some language that will look better than the one you are using now. keep learning new languages, however, since the experiences will heighten your abilities to know when a language is wrong for a project.", "@johnl: my new favorite example in this particular category is \"parallelizeable database transactions\", which are forced to be serial when made into a monad.", "what books should i read to fully understand this?", "whoa...it's so...imperative.:)", "in haskell, downcasting is not allowed. you can use code_removed, but the trouble with that is there is no longer any way to get back to a functor that you know. when you have an code_removed, all you know is that you have an code_removed for some code_removed, so all you can do is code_removed (getting you another code_removed). thus, code_removed is in fact equivalent to code_removed. you can add structure to code_removed to make it more useful, and we'll see a bit of that later on. functor coproducts but first, i'll share the way that i would probably end up doing this in a real program: by using functor combinators. code_removed as the data type reads, code_removed is a functor whose values can be either code_removed or code_removed. then you can use, for example: code_removed and you can observe by pattern matching: code_removed it gets ugly as you add more functors: code_removed but i recommend it as long as you can handle the ugliness, because it tracks the list of possible functors in the type, which is an advantage. (perhaps you eventually need more structure beyond what code_removed can provide; as long as you can provide it for code_removed, you're in good territory.) you can make the terms a bit cleaner by creating an explicit union, as ganesh recommends: code_removed but you pay by having to re-implement code_removed for it (code_removed can help). i prefer to put up with the ugliness, and work at a high enough level of abstraction where it doesn't get too ugly (i.e. once you start writing code_removed it's time to refactor & generalize). coproduct can be found in the comonad-transformers package if you don't want to implement it yourself (it's good exercise though). other common functor combinators are in the code_removed namespace in the transformers package. existentials with downcasting code_removed can also be extended to allow downcasting. downcasting must be explicitly enabled by adding the code_removed class to whatever you intend to downcast. every concrete type is an instance of code_removed; type constructors are instances of code_removed (1 argument); etc. but it doesn't come for free on type variables, so you need to add class constraints. so the code_removed solution becomes: code_removed which allows downcasting: code_removed this solution is actually cleaner than i had expected to be, and may be worth pursuing.", "i spoke to the author a while back, and he confirmed that the online version of the book is out of date. there's a more up-to-date version on pdf: [here]", "it's a bit orthogonal to your question, but you can pull off these proofs by using a set of equational reasoning combinators \u00e0 la agda. cf. this proof of concept", "@passerby well then you just need to update the guarantee. code_removed guarantees that code_removed will equal 5 if there is no way that code_removed could be simultaneously modified in another thread or if code_removed is a type that can be atomically written or if you're on a weak consistency model. that doesn't invalidate the point that there are guarantees. (alternatively, you could state that you are guaranteeing to the compiler that you won't modify code_removed in multiple threads, and if you break your guarantee the compiler is free to break its).", "haha yeah, i'm sure the paper is where i got a fair bit of my chronology from...", "you can leave out code_removed in the constraints. the code_removed variable is exposed (unlike code_removed) so the constraint can be added just where it's needed. that should then solve the code_removed problem. code_removed then needs a code_removed constraint which is no problem to add.", "\"what are the consequences of having absurdly long constructor names\": for one, they don't fit in a stackoverflow comment.", "in ghc with the code_removed language extension and importing code_removed, you can also use the signature code_removed.", "when i code_removed a haskell script into ghci, it changes the prompt from code_removed to code_removed. after i'm done with this script, how can i go back to the code_removed prompt? there seems to be no documentation regarding this.", "how about code_removed?", "why was this question tagged \"web-services\"?", "i'm afraid this does very much fit in the \"i'm having more trouble than i expected driving my new aeroplane around the carpark\" category of problems. in reality, a list isn't the best way of storing non-homogenous data, in very much the same way that an iterator isn't the easiest way to produce it. it's not impossible, it's just inconvenient because it's the wrong tool. why not use a record for the disparate bits and lists only for when you have multiples of exactly the same thing?", "data.ord code_removed (for those wondering about the writing the code_removed shorter)", "@tomsmeding i can understand that if only output and simple input that doesnt change the control path or is not used for calcuation is involved. however if you have input and then decide according to that input, my understanding is that you cannot defer this to an external engine as a seqeuence of actions, unless you calculate both control paths concurrently or if the input is used for a calculation, calcuate all possible outcomes in advance or by passing a language to the external engine. i'm not a functional expert though.", "this works because of operator precedence. the function application operator, juxtaposition or code_removed (the space), has the highest precedence, so code_removed parses as code_removed, which is equivalent to code_removed; since function application is left-associative, this is then equivalent to code_removed. in general, any binary operator can be given a precedence with a fixity declaration, such as code_removed the code_removed or code_removed says whether the operation is left- or right-associative (that is, whether code_removed groups as code_removed or code_removed); the number\u2014an integer between 0 and 9\u2014specifies the precedence level. higher numbers mean higher precedence (with application having an effective precedence of \u221e); for instance, code_removed and code_removed have precedence 7, and code_removed and code_removed have precedence 6. to check the precedence of an operator in ghci, just type code_removed (or whichever operator) at the prompt. and just as a note: your code will work, but it's not how i would typically write it. if you're curious, in haskell, i would write that code with the code_removed operator, which just performs function application but is low precedence: code_removed. if i had more functions to apply, i would use the composition operator: code_removed. it reads the other way, but it's what you typically find in haskell.", "code_removed i think different people expand these differently. i don't meant that they produce different results or anything, just that among people who do it correctly there isn't really a standard notation. here's how i would do it: code_removed this is the same as sepp2k's and leftaroundabout's answers, just that they write it funny. sepp2k's answer has a code_removed expression appearing seemingly out of nowhere\u2014the multi-equational definition of code_removed got implicitly rewritten as a single code_removed expression. leftaroundabout's answer has a code_removed thing in it which apparently is a notation for \"i have to force the argument until it looks like either code_removed or code_removed\". bhelkir's answer is similar to mine, but it's recursively forcing all of the subexpressions of the result as well, which wouldn't happen unless you have a consumer that demands it. so no disrespect to anybody, but i like mine better. :-p", "i do see why the first list of items very vaguely feel like they have various levels of (un)definedness -- i'm not trying to be difficult -- but i'd like to know if there's more to this since the answer says this comes from mathematical theory.", "because code_removed literally means anything apart from explicitly specified patterns. when you specify code_removed it means anything which can be represented as a list containing at least 1 element, without bothering with what or even how many elements the list actually contains. since the case with an explicit pattern for empty list is already present, code_removed might as well be replaced by code_removed. however, representing it as code_removed gives you the flexibility to not even explicitly pass the empty list pattern. in fact, this will work: code_removed demo", "\"monad\" roughly means \"pattern\"... no.", "who first said the following? a monad is just a monoid in the category of endofunctors, what's the problem? and on a less important note, is this true and if so could you give an explanation (hopefully one that can be understood by someone who doesn't have much haskell experience)?", "there are some ghc extensions that are too good to live without. among my favorites are multiparameter type classes scoped type variables higher-rank types generalized algebraic data types (gadts) of these the really essential one is multiparameter type classes. some ghc extensions are very speculative and experimental, and you may want to use with caution. a good way to identify a stable and trusted extension is to see if it is slated for inclusion in haskell prime, which is hoped to be the successor the haskell 98. i second don stewart's suggestion that every extension should be marked using the code_removed pragma in the source file. don't enable extensions using command-line options.", "it depends on x in -ox code_removed well, in this simple case ghc (7.0.2) really is sufficiently smart.", "@robertharvey might not be any danger whatsoever, but oftentimes you find that violations of purity lead to incorrect expectations about behavior or tricks to get around module encapsulation. i'd be more than happy to use code_removed in real code (i already do) but i noticed today that it violates haskell semantics.", "\"after all a software which doesn't interact with the outside world isn't any useful other than doing some mathematical computations.\" as far as i understand, even in this case the input to the computations would be hard-coded in the program, also not very useful. as soon as you want to read input data to your mathematical computation from file or terminal, you need impure code.", "the history of the language, including major milestones and design decisions, is described in a history of haskell: being lazy with class. code_removed", "let me rewrite the example using a system-f-like notation, wherein we pass types as well. below, code_removed stands for type-abstraction (big lambda), as well as dictionary abstraction. also, code_removed stands for type/dictionary application. before doing that, recall the type of code_removed: code_removed here's the annotated code (beware, not for the faint of heart): code_removed (above i pretended code_removed,code_removed,code_removed are type constants to avoid further type-level lambdas.) the important parts: code_removed and code_removed are being used at specific types. that is they are being applied to type-level arguments before being fed to code_removed. code_removed is being applied at the type level to types (code_removed, etc) which are not the polytypes of code_removed and code_removed as you can see, the original code is far from being trivial. type inference is able to add the needed type-level lambdas and applications. after those are added, we can not simply eta contract code_removed anymore. in the pointfree variant, type inference would need to do more than in the pointful case. while the first argument of code_removed is of type code_removed, the first argument of code_removed must be of the form code_removed, which does not unify for code_removed. indeed, there's no way to successfully solve the typing attempt below: code_removed above there's no code_removed,... that can lead to the wanted type. the only possibility would be to instantiate the code_removed-quantified variables hidden in the code_removed types, but to do that we need a point. the compiler might eta-expand that code for you so that points appear and so can be instantiated, theoretically speaking, but in practice will not. (also, eta expansion is not always valid in haskell: e.g. code_removed loops while code_removed returns code_removed).", "@missingfaktor: it means the structural information of a code_removed, the part that's not parametric. the state value in code_removed, failure in code_removed and code_removed, the number of elements in code_removed, and of course arbitrary external side effects in code_removed. i don't care for it as a generic term (like the code_removed functions using \"empty\" and \"append\", the concept is more generic than the term suggests at first) but it's fairly common and serves the purpose well enough.", "ghc's base now supports streams which is why the results are similar. uvector's terrible performance in -o0 is expected because it completely relies on streaming to get any decent performance. also, your comments indicate you use uvector but your module import indicates you use vector. in any case it'd be nice to look at data.vector.unboxed performance rather than data.vector", "thanks, i think i'll try this workaround. what's strange is that according to comments here, linker detection is supposed to happen when you code_removed a bindist, but i haven't found that to be the case when i am working from a bindist that i compiled from a source distribution. anyone know what i might be doing wrong?", "code_removed moved from the code_removed package to code_removed in base version code_removed (ghc 7.10). if you look at the cabal file for code_removed you'll see that it only includes code_removed for old code_removed versions. now, code_removed is defined as chi suggests: code_removed which is perfectly valid. i think the idea behind the old definition is something like this: consider the type code_removed this type doesn't get the job done, because it's actually possible to define a non-bottom (coinductive) value with that type: code_removed we can fix that problem by using a strictness annotation, which (at least sort of) forces the type to be inductive: code_removed under assumptions that may or may not actually hold, but at least morally hold, we can legitimately perform induction on any inductive type. so code_removed will always terminate if, hypothetically, we have something of type code_removed. the final step is replacing the single-strict-constructor datatype with a newtype: code_removed this is always legitimate. the definition of code_removed, however, has changed meaning because of the different pattern matching semantics between code_removed and code_removed. to preserve the meaning precisely, code_removed should probably have been written code_removed (avoiding code_removed to skirt a now-fixed bug in the interaction between newtype constructors and bang patterns; but for ghc 7.10 (ha!) this form doesn't actually produce the desired error message because it's \"optimized\" into an infinite loop) at which point code_removed. thankfully, it doesn't actually matter in the end, because the whole old definition is a bit of a silly exercise.", "ulfnorell: sorry, i wasn't clear. suppose you have one function that will work with code_removed and another for code_removed, and you want to use the first only if the type matches. yes it's possible, but the mechanisms for enabling it are clunky. and this is very simple logic; if you have more complex logic it's worse. also, you may need to re-write a lot of code in cps. and you still don't have a type-level expression that's dependent on a term at the value level", "you might just as well ask, why is there no single element tuple in mathematics?", "yes, there's a nice way of updating record fields. in ghci you can do -- code_removed", "@nominolo: i didn't mean to demean code_removed, and i don't think that it's bad. imho it is a very helpful tool for the programming process, and especially for haskell beginners, and i'm grateful that it exists.", "@lqueryvg two ways to stop left folds: 1. code it with a right fold (see code_removed); 2. convert it into a left scan (code_removed) and stop that with code_removed or similar. uh, and 3. use code_removed.:)", "either code_removed seems to be no more, or i suck at searching. which one is the case?", "@mb21: in case you're just pointing out that there are too many brackets, note that a->b->c is actually only short for a->(b->c). writing this particular example as (a -> b) -> (ta -> tb) is strictly speaking just adding unncessary characters, but it's morally \"the right thing to do\" as it emphasises that fmap maps a function of type a -> b to a function of type ta -> tb. and originally, that's what functors do in category theory and that's where monads come from.", "another way to explain the behaviour of code_removed is that it starts with the empty list, and adds more elements until there aren't any left. i suppose that aligns fairly well with your definition of code_removed as \"every element that isn't the last\".", "if i've understood correctly, ienumerable is derived from monads. i wonder if that might be an interesting angle of approach for those of us from the c# world? for what it's worth, here are some links to tutorials that helped me (and no, i still haven't understood what monads are).", "gawi: it is part of ghc 7. the release candidate for that was put out two weeks ago.", "in the code_removed newtype, i can't figure out what the code_removed constraint is doing. could you explain?", "please optimize your code, or get others to help you do so, before asking questions like #1 and #2.", "you can see how ghc treats underscore-prefixed identifiers and warnings here: haskell.org/ghc/docs/7.4.1/html/users_guide/options-sanity.h\u200c\u200btml", "@mljrg yes. you presumably already know that writing the expression code_removed is just syntactic sugar for code_removed. the same is true when defining a function, so code_removed is syntactic sugar for code_removed which is equivalent to code_removed. it's just a slightly nicer way of defining the function code_removed. i could also have written code_removed and it would mean the same thing.", "first find the type of the function you need. to \"check if\" means to return either true or false, a bool. so the function takes an int, a list of int (aka [int]) and returns bool: code_removed now ask hoogle. code_removed hoogle is a very useful tool. you can integrate it with ghci.", "@richizy if you're actually applying code_removed in this context, then yes - but then the \"final\" one would be applying to something other than code_removed. if you're not applying code_removed, then it's no different to code_removed being a value.", "with the new polykinded code_removed you no longer need code_removed.", "you want to compose those code_removeds. in vim, with the cursor on the definition of code_removed, do this: code_removed.", "let's start with a code example: code_removed this code doesn't compile (syntax error) in plain haskell 98. it requires an extension to support the code_removed keyword. basically, there are 3 different common uses for the code_removed keyword (or at least so it seems), and each has its own haskell extension: code_removed, code_removed/code_removed, code_removed. the code above doesn't get a syntax error with either of those enabled, but only type-checks with code_removed enabled. scoped type variables: scoped type variables helps one specify types for code inside code_removed clauses. it makes the code_removed in code_removed the same one as the code_removed in code_removed. a confusing point: you may hear that when you omit the code_removed from a type it is actually still implicitly there. (from norman's answer: \"normally these languages omit the forall from polymorphic types\"). this claim is correct, but it refers to the other uses of code_removed, and not to the code_removed use. rank-n-types: let's start with that code_removed is equivalent to code_removed, except for when code_removed is enabled. this means that it works for every code_removed and code_removed. let's say you want to do something like this. code_removed what's must be the type of this code_removed? it's code_removed. to see why, let's try to code it: code_removed \"hmm.. why does ghc infer that the tuple must contain two of the same type? let's tell it they don't have to be\" code_removed hmm. so here ghc doesn't let us apply code_removed on code_removed because code_removed and code_removed wants an code_removed. we really want our function to get a function that accepts any possible code_removed! code_removed so it's not code_removed that works for all code_removed, it's the function that it gets that does. existential quantification: let's use an example: code_removed how is that different from rank-n-types? code_removed with rank-n-types, code_removed meant that your expression must fit all possible code_removeds. for example: code_removed an empty list does work as a list of any type. so with existential-quantification, code_removeds in code_removed definitions mean that, the value contained can be of any suitable type, not that it must be of all suitable types.", "c.a.mcc: i read \"do x, then do y, then...\" as your own interpretation/bias showing through, rather than anything actually in the nature of arbitrary monads. i wouldn't use these terms or this mindset for many of my favorite monads, e.g., code_removed, code_removed, code_removed, code_removed, code_removed, code_removed, and all trie types. bias aside, monadness is nothing more than two generic operations and their three laws. there is nothing intrinsically imperative there, and if there were, they wouldn't hold for the monads i mentioned (unless one is willing to argue that everything is imperative, even if trivially).", "if you removed the code_removed, your code would not typecheck. the reason for the code_removed is to maintain proper types. there is a type (a monad, actually, but it's easier to think of as just being a type) code_removed, which consists of elements of the form code_removed and code_removed. since code_removed has type code_removed, an expression that can evaluate to either code_removed or some value of type code_removed is not properly typed. if a function returns code_removed in some cases, any expression using that function must have some way of checking for that (code_removed or a case statement), so as to handle all possible cases.", "i totally agree about teaching purposes. maybe we should set up a code_removed package which contains the original simpler versions.", "@nikolajk right, they're the same. i'm just more familiar of thinking about it in terms of code_removed for list.", "@aaditmshah \"the exception confirms the rule\"", "i believe it has origins predating haskell. go is a popular name for named lets in scheme (google.com/\u2026, google.com/search?q=scheme+%22let+go%22+-let's+car+cdr)", "happy to use ghc extensions", "if you're looking for a list or higher-order function, it's already there there's sooo many convenience and higher-order functions in the standard library. code_removed", "i think the op already realises this, but for the benefit of others who come here with the same confusion: code_removed is not actual code! the symbol code_removed (which is just an ascii-art rendering of the mathematical symbol code_removed) means bottom1, but only when we're talking about haskell. in haskell code it does not have this meaning2. the line code_removed is a description of a property of the actual code for code_removed; that if you call it with first argument code_removed and pass any bottom value as the second argument, the result is equal to code_removed. the reason they would want to say exactly this is because the technical definition of what it means for a function code_removed to be non-strict is when code_removed is not code_removed. but there is no role of code_removed (or code_removed, or code_removed, or the concept of bottom at all) in defining haskell functions (in code). it has to be impossible to pattern match on an argument to see whether it is code_removed, for a number of reasons, and so there is no actual symbol for code_removed in haskell code3. code_removed is documentation of a property that is a consequence of the definition of code_removed, not part of its definition. as a description of this property code_removed is a less specific claim; it would be saying that whatever you call code_removed on, it returns code_removed. it amounts to exactly the same thing, since the only way code_removed can return something non-bottom is if it never examines its second argument at all. but it's speaking less immediately to the definition of non-strict-ness. as code forming part of the definition of the function code_removed can't be compared and contrasted to code_removed. they're not alternatives, the first is valid code, and the second is not. 1 which is the \"value\" of an expression that runs forever, throws an exception, or otherwise falls to evaluate to a normal value. 2 it's not even a valid haskell identifier, since it contains both \"namey\" characters (code_removed) and \"operator\" characters (code_removed). so it can't actually be a symbol meaning anything at all in haskell code! 3 code_removed is often used for code_removed, but it's more of a variable referring to a code_removed value than the actual thing itself. much like if you have code_removed you can use code_removed to refer to the list code_removed, but you can't use it as a pattern to match some other list against; the attempted pattern match would just be treated as introducing a new variable named code_removed or code_removed shadowing the old one.", "@thedayturns for historical reasons there are things that are less generic than they should be. see, for example, stackoverflow.com/questions/6824255/\u2026 or stackoverflow.com/questions/7463500/\u2026", "what does the term 'effect' mean?", "@c.a.mccann i thought of something. for all the three universally quantified types that i mentioned earlier (i mistakenly wrote existentially quantified in my previous comment), they denote the mogensen-scott encoding of data types in the lambda calculus. hence, code_removed is equivalent to code_removed; and code_removed is equivalent to code_removed; and code_removed is equivalent to code_removed for which code_removed and by substitution we get code_removed.", "@fuzxxl: using gadt-style syntax, you can also put the context on the data constructor, in which case it becomes available automatically by pattern matching. otherwise, yes, you need to add the code_removed constraint whenever it's used.", "what does code_removed do? i know what code_removed and code_removed do. is it just both of them put together or is it a completely different function?", "what do they mean by saying that code_removed? the function code_removed could be defined as code_removed i.e. taking a function and an argument and returning the result of the application. equivalently, thanks to currying, we can interpret that as taking only code_removed and returning a function of code_removed. code_removed here, we can note that the function code_removed maps any input code_removed to code_removed -- that's also what code_removed does! so, we can simplify the definition to code_removed now, this is the same as the identity function definition code_removed, so we might as well write code_removed in which cases is that statement true? does that mean i can use one instead of the other? the equation holds always, but there are two caveats. the first one is that code_removed has a more restricted type than the one of code_removed, since code_removed holds only for a function code_removed, not for any value code_removed. this means that you can replace code_removed with code_removed, but not vice versa. when writing code_removed one could make the implicit type argument explicit and write that, for any types code_removed and code_removed code_removed the other caveat is that, in the presence of higher-ranked function, code_removed receives some special handling during type checking, while code_removed does not. this is point 3 blow. in the base, what is meant by saying that code_removed is \"slightly magical (it can return unlifted types)\" and \"being wired in\"? normally, in polymorphic functions such as code_removed the type variable code_removed can be instantiated to other types, but only under some restrictions. for instance, code_removed can be instantiated to code_removed, but can not be instantiated to another polymorphic type code_removed. this keeps the type system predicative, which helps greatly during type inference. usually, this is not an issue in everyday programming. however, some functions use rank-2 types, e.g. code_removed code_removed if we write code_removed the type system can type check that. but if we use the common idiom code_removed then the type inference engine has to take the type of code_removed code_removed and choose code_removed which is polymorphic, hence forbidden. since this idiom is too common, the ghc developers decided to add a special case to the typing of code_removed to allow this. since this is a bit ad-hoc, if you define your own code_removed (possibly under another name), and try to type check code_removed this will fail since it does not use the special case. further, code_removed can not be instantiated to unboxed types such as code_removed, or unboxed tuples code_removed. these are ghc extensions which allow writing functions which pass a \"raw\" integer, without the usual thunk wrapper. this can change the semantics, e.g. making functions stricter than they are. unless you want to squeeze more performance from some numeric code, you can ignore these. (i'm leaving this part here, but lisyarus already covered it more precisely.) code_removed basically, code_removed is code_removed, but with a more restrictive type. code_removed can be used on arguments of any type, code_removed instead takes a function argument. code_removed note that code_removed, so the type of code_removed is indeed a special case. and what about \"different types in different scenarios\"? i thought that since haskell is a strongly typed language, once you define a type signature, that signature is retained until the end of time. is that not true? are there cases where one can change a function's type? in the code of the libraries which define code_removed, ghc has to play some tricks to get the special typing rules to work for the other libraries and programs. for that, apparently it is required not to use code_removed in said library. unless you are developing ghc or the code_removed module which happens to define code_removed, you can ignore this. it is an implementation detail internal to the compiler, not something that the user of the compiler and libraries must know.", "i am new to haskell, and i am struggling with debugging my code. fixing an error leads to other errors... here is my code. code_removed i am now getting two errors which i wrote in comments. if you know what's wrong with my code, please share your idea and save my time... thank you very much.", "whenever possible, reuse library code. code_removed try it out in ghci: code_removed", "@stakx: yes, true. but i didn't mean that monads are an abstraction that you cannot learn or shouldn't learn; only that it's best to learn it after you've seen enough concrete examples to perceive a single underlying abstraction. see my other answer here.", "i family of coq and agda you can also look at qi ii.", "you seem to be the only one who finally addressed my main problem with understanding monads. nobody ever talks about how can the value be extracted. is it implementation dependant?", "@rotsor: whoops, i meant code_removed, because that is the only legal value.", "alpha is a non-free type variable, not a usual variable. so to explain generalization rule much more must be explained.", "no, it's completely natural. frominteger is meant to be an embedding homomorphism, and code_removed is idosorphic to code_removed.", "(by the way, @hammar, i took the liberty to change \"side effect\" to \"effect\" in this answer due to the reasons outlined in the comment above.)", "@tair: ocaml is not lazy. i studied several oss haskell code bases and didn't think laziness seemed particularly advantageous.", "i have done real production web applications in haskell. here is the stack i used: postgresql database backend hdbc postgres to connect to it xhtml to generate html. it is a bit of a funny syntax, but at least you have lambda-abstraction. fastcgi to connect the backend to the lig doing the web serving. the whole web application is a single haskell program, compiled to native code ghc. i wrote the code to do request routing (and reverse routing) by hand.", "you would be better off removing the file and simply recovering if it does not exist: code_removed this avoids the race condition of someone deleting the file between your code checking whether it exists and deletes it. it might not matter in your case, but it's good practice anyway. note the code_removed line \u2014 this is because the prelude contains older functions from exception handling which are now deprecated in favour of control.exception, which also has a function named code_removed; the import line simply hides the prelude's code_removed in favour of control.exception's. however, that still leaves your more fundamental underlying question: how do you write conditionals in code_removed? well, in this case, it would suffice to simply do code_removed (using control.monad.when). but it's helpful here, as it usually is in haskell, to look at the types. both branches of a conditional must have the same type. so to fill in code_removed we should look at the type of code_removed; whatever code_removed is, it has to have the same type. system.directory.removefile has the type code_removed, so code_removed has the type code_removed. so what we want is an io action with a result of type code_removed that does nothing. well, the purpose of code_removed is to construct an action that has no effects, and just returns a constant value, and code_removed has the right type for this: code_removed (or more generally, code_removed). so code_removed is code_removed (which you can see i used in my improved snippet above, to do nothing when code_removed fails because the file doesn't exist). (by the way, you should now be able to implement code_removed with the help of code_removed; it's really simple:)) don't worry if you find it hard to get into the haskell way of things at first \u2014 it'll come naturally in time, and when it does, it's very rewarding.:)", "cool. i wasn't aware of this package. this is the ultimate split package as it gives much control over the operation (trim space in results, leave separators in result, remove consecutive separators, etc...). there are so many ways of splitting lists, it is not possible to have in single code_removed function that will answer every needs, you really need that kind of package.", "this is incredibly valuable. i'd managed to vague up some intuitions about this whole f-algebra business from reading and examples (e.g., from seeing their use with catamoprhisms), but this is just all crystal clear even to me. thanks!", "code_removed", "... th works fine without the interpreter.", "the branch of the first one holds a list of trees, so potentially any number of subtrees. the 2nd is explicitly two subtrees, thus a binary tree.", "if you use jquery, this explanation can be very helpful, especially if your haskell isn't strong", "i have a discussion that treats the monad as a type expansion where the original type, b, is converted to an expanded type m<b> and the associated operators are wrapped to now service m<b>. these wrappers are what will handle the peculiarities of the monad. in particular, extracting the original type from the expanded type and passing it to it's wrapped operator and subsequently promoting the result. the benefit of the monad is that you retain simple declarative expressions. in my treatment i discussed expanding the numeric types system to include a divbyzero value to obviate the need to check", "oh, in february we also had 6 people attend a \"snap summit\" in new york city. one even flew in from out of state on very short notice for the sole purpose of hacking on snap.", "here are a few of the resources that i've found useful after \"getting the hang of\" monads: as superbloup noted, brent yorgey's typeclassopedia is indispensable (and it does in fact cover arrows). there's a ton of great stuff in real world haskell that could be considered \"after monads\": applicative parsing, monad transformers, and stm, for example. john hughes's \"generalizing monads to arrows\" is a great resource that taught me as much about monads as it did about arrows (even though i thought that i already understood monads when i read it). the \"yampa arcade\" paper is a good introduction to functional reactive programming. on type families: i've found working with them easier than reading about them. the vector-space package is one place to start, or you could look at the code from oleg kiselyov and ken shan's course on haskell and natural language semantics. pick a couple of chapters of chris okasaki's purely functional data structures and work through them in detail. raymond smullyan's to mock a mockingbird is a fantastically accessible introduction to combinatory logic that will change the way you write haskell. read g\u00e9rard huet's functional pearl on zippers. the code is ocaml, but it's useful (and not too difficult) to be able to translate ocaml to haskell in your head when working through papers like this. most importantly, dig into the code of any hackage libraries you find yourself using. if they're doing something with syntax or idioms or extensions that you don't understand, look it up.", "@bmeph i would say that instead of thinking of a function as a counterexample to the idea that functors are containers, you should think of function's sane functor instance as a counterexample to the idea that functions aren't containers. a function is a mapping from a domain to a codomain, the domain being the cross product of all of the parameters, the codomain being the output type of the function. in the same way a list is a mapping from the naturals to the inner type of the list (domain -> codomain). they become even more similar if you memoize the function or don't keep the list.", "[..] is a big pitfall regardless. code_removed should have type code_removed and there should be another function, code_removed", "a great way to learn more about anything (any function) is to remember that everything is a function! that general mantra helps, but in specific cases like operators, it helps to remember this little trick: code_removed and code_removed just remember to use code_removed liberally, and wrap your operators in code_removed!", "how about code_removed?", "i think holes are at the expression level - you write code_removed in an expression, and the compiler tells you what type it should have: haskell.org/haskellwiki/ghc/typeholes", "\"applicative is almost the same as monads, except that effects cannot depend on previous results.\"... a lot of stuff clicked into place for me with this line, thanks!", "everywhere i've tried using code_removed, code_removed has worked as well. why did the creators of haskell feel the need for a code_removed function? couldn't it just be what is currently known as code_removed and code_removed could be removed from the language?", "@antonyhatchkins the language extension code_removed removes this restriction. to use it, put code_removed on top of the source file.", "these are my favorite haskell: functional programming with types code_removed real world haskell code_removed", "i am a newbie to haskell but find it relatively simple to explore machine learning codes with haskell (such as knn classifier and perceptron)", "@timo: the problem i had with learn you a haskell was it didn't have many practical examples - while it taught the principals well, you never really got around to writing an actual useful program. rwh didn't have this problem, but was a bit too dense for a new programmer. so starting with lyah and moving to rwh seemed like the best compromise without doubling up on too much. both are excellent resources though so stick with whatever works for you.", "@erikhesselink: you introduced an error with your edit. code_removed", "what is 1 + 2???", "i still can't get those typeclass programming shenanigans, anyone who does that is clearly a wizard to me.", "your answer made me happy initially, but now after a bit of time to digest, shouldn't the compiler not be able to make that optimization for me? after all, i can see it heuristically almost immediately, and i'm sure these kinds of patterns occur all the time in haskell. is there something preventing such compiler optimizations from being implemented?", "obviously if it should never be used, it wouldn't be in the standard libraries.;-) there are a number of reasons why you might use it. examples include: initialising global mutable state. (whether you should ever have such a thing in the first place is a whole other discussion...) lazy i/o is implemented using this trick. (again, whether lazy i/o is a good idea in the first place is debatable.) the code_removed function uses it. (yet again, it turns out code_removed is rather less useful than you might imagine.) perhaps most significantly, you can use it to implement data structures which are referentially transparent, but internally implemented using impure code. often the code_removed monad will let you do that, but sometimes you need a little code_removed. lazy i/o can be seen as a special-case of the last point. so can memoisation. consider, for example, an \"immutable\", growable array. internally you could implement that as a pure \"handle\" that points to a mutable array. the handle holds the user-visible size of the array, but the actual underlying mutable array is larger than that. when the user \"appends\" to the array, a new handle is returned, with a new, larger size, but the append is performed by mutating the underlying mutable array. you can't do this with the code_removed monad. (or rather, you can, but it still requires code_removed.) note that it's damned tricky to get this sort of thing right. and the type checker won't catch if it you're wrong. (what's what code_removed does; it makes the type checker not check that you're doing it correctly!) for example, if you append to an \"old\" handle, the correct thing to do would be to copy the underlying mutable array. forget this, and your code will behave very strangely. now, to answer your real question: there's no particular reason why \"anything withou pointers\" should be a no-no for code_removed. when asking whether to use this function or not, the only question of significance is this: can the end-user observe any side-effects from doing this? if the only thing it does is create some buffer somewhere that the user can't \"see\" from pure code, that's fine. if it writes to a file on disk... not so fine. hth.", "you could do this using existential types, but how would you get the values back out of the resulting list?", "i swear there used to be a t-shirt for sale featuring the immortal words: what part of do you not understand? in my case, the answer would be... all of it! in particular, i often see notation like this in haskell papers, but i have no clue what any of it means. i have no idea what branch of mathematics it's supposed to be. i recognise the letters of the greek alphabet of course, and symbols such as \"\u2209\" (which usually means that something is not an element of a set). on the other hand, i've never seen \"\u22a2\" before (wikipedia claims it might mean \"partition\"). i'm also unfamiliar with the use of the vinculum here. (usually it denotes a fraction, but that does not appear to be the case here.) if somebody could at least tell me where to start looking to comprehend what this sea of symbols means, that would be helpful.", "\"haskell programmers are typically very smart\" -> this \"reason\" seems to appear in most of the discussions about paradigms, and specifically when haskell is mentioned. i love haskell, but that's just pure idiocy. prejudices are not good; there are no valid dogmas in computer science. treating a fallacy as bad as that one as a valid argument is just pitiable.", "thanks, @tomcrockett. and one more question, because i have no background in category theory. i am a little bit confused about \u03bc(\u03b7(t)) = t = \u03bc(t(\u03b7)). my understanding is that \u03b7 is a morphism(or arrow) pointing from object i to object t (well, of course, in category of endofunctors, a morphism is a natural transformation as you mentioned). then what does \u03b7(t) mean? what puzzles me even more is the meaning of t(\u03b7), considered t is an object and \u03b7 is a morphism. thanks a lot!", "thank you for your answer, it is exactly what i was looking for! could you help with a problem i ran into when using it. if i change the (+) operator to say pair (a,b) + pair (c,d) = pair (a+b,c+d) it keeps complaining about incompatible types. how to overcome this? i only work with float numbers.", "@missingno: yeah, they missed code_removed", "it took me 5 minutes to understand how this works:)", "it no longer depends on double-conversion or text-format.", "parallel list comprehension (special ghc-feature) code_removed", "what is the difference when i write this? code_removed", "@jpmc26 most likely it would get closed there as \"primarily opinion-based\"; here it at least stands a chance (as shown by the huge number of upvotes, rapid reopen yesterday, and no more close votes yet)", "i'm running into odd behavior with the interactive-haskell repl in code_removed. when i source a file, the code_removed mini buffer shows a series of interactive prompts: code_removed if i leave either the cabal directory or the current directory to the default value of the project directory, the repl is unresponsive. i get a lambda prompt in the interactive haskell window, i can type, but when i press enter, it never evaluates. the cursor stays on the same line as if i did not press enter at all. if i change both of those directories to some path other than my project directory, then the repl behaves normally and evaluates expressions as expected.", "@emresevin\u00e7 i wonder what you would expect code_removed to return.", "@danielwagner not really sure how downcasting is connected with the topic. i need only upcast. yes i can turn this into list of code_removeds as mentioned in the answer by @erikr but the question more about readability: repetetive code_removeds doesn't look good for me.", "i tried this, but it says: \"illegal instance declaration for `num (pair a a)' (all instance types must be of the form (t a1... an) where a1... an are distinct type variables, and each type variable appears at most once in the instance head.\"", "you can try passing code_removed as a ghc option. at some point, it did help me to get rid of module qualifiers in names.", "this answer helped, but i think it would have confused me had i not met 'join' on the nicta course and read haskellforall.com/2012/06/\u2026. so for me, the trick to understanding is to read a lot of answers until it sinks in. (nicta reference: github.com/nicta/course/blob/master/src/course/bind.hs)", "@yitz - btw, semantics are what's defined irrespective of which compiler you use. the non-strict semantics of haskell are part of the specification of haskell - the compiler can only choose to use strict evaluation (or some other order) if the resulting semantics are equivalent to lazy evaluation. of course calling haskell lazy is sloppy, but claiming that the semantics is whatever the compiler does is just plain wrong.", "code_removed looks like this: code_removed looks like this: context: fold on the haskell wiki", "at cmu, i learned denotational semantics and program derivation (systematic transformation of specifications to implementations), both of which have had a profound impact on my approach to programming. you'll see these two themes regularly on my blog. when i work on a software library, i pick a small number of types and start with a central question: \"what does it mean?\". when i see low-level code, e.g., imperative/code_removed, i ask \"of what denotative abstraction is this code an implementation, and how might that implementation be derived from the abstraction?\"", "@scott: i still don't quite see the difference\u2026. but perhaps better to get to the crux of the matter: can you suggest a better name than \"monad\"? (\"type operator\" is a poor choice, for reasons already mentioned by jared.)", "@tikhonjelvis i'm trying to understand algebraic semantics of computation and their generalization in the setting of category theory, so i was looking for references to seminal papers. it turns out the \"mathy equivalent\" i was looking for was the signature and how f-(co)algebras denote all signatures in a single function (functor) which is a sum (co-product) of products. this also ties back nicely to how algebras formalize algebraic data types. i'm pretty sure there's more category theory goodness to grok here but this is probably out of the scope for this discussion.", "you don\u2019t need to define auxiliary functions or employ lenses. standard haskell has already what you need. let\u2019s take the example by don stewart: code_removed then you can just say code_removed to get an updated record.", "\"learn you haskell\" doesn't mention this at all.", "these instances exist in reducers, an edward kmett package. your code_removed is known there as code_removed, while code_removed is encoded through the code_removed newtype.", "was this intended as a comment on this answer? because it's not clear, and this isn't an answer on its own.", "code_removed should always do the same thing as code_removed. i've removed the example from the answer.", "@chuck - it appears to have been written in c. fourmilab.ch/autofile/www/subsection2_38_3_1.html", "in addition to irc freenode, there is also lately a growing lively discussion on haskell in discord chats.", "yeah, but that would mean that we need to handle the special case whenever we call code_removed (e.g. by wrapping every call into a code_removed)... i don't like this very much.", "oh! and since code_removed is just a type family, code_removed is a data family which lets you avoid going around making new names for data types like code_removed, code_removed, code_removed, code_removed. it's just convenience to have both code_removed and code_removed.", "this quote probably originates from the end of the introduction of tackling the awkward squad: monadic input/output, concurrency, exceptions, and foreign-language calls in haskell which says \"in short, haskell is the world\u2019s \ufb01nest imperative programming language.\"", "i can do the following: code_removed i can derive code_removed and get reads to read those too. but i've never gotten reads to return more than one tuple in the list. why does code_removed return a list?", "the answers to my question about criterion may contain some helpful usage examples stackoverflow.com/questions/6637968/\u2026.", "there's some substantial extra flexibility from the fact that the chosen implementation can depend on others in polymorphic recursive contexts. that's unlikely to show up in a code_removed situation, but it happens in real code for other classes like code_removed, code_removed, code_removed, code_removed, code_removed, code_removed, etc. look up \"nested types\" and prepare to be confused for a while. unrelatedly, code_removed throws in extreme dynamic fun!", "one option would be to create a specific data type for your use case, with the additional advantage of having proper names for things. another would be to create a specialized code_removed tuples as: code_removed so the tuple is homogeneous in values, but heterogeneous in functors. then you can define code_removed and code_removed with this approach, you can pattern match on the result easily, without losing information about the types of the individual elements, their order etc. and, you can have similar instances for code_removed, code_removed, code_removed etc. also you don't need to implement the code_removed instance yourself, you can use ghc's deriving extensions, so all you need to write to get all the instances is is just code_removed and even this can be further automated for arbitrary length using template haskell. the advantage of this approach is mainly in the fact that it just wraps ordinary tuples, so you can seamlessly switch between code_removed and code_removed, if you need. another alternative, without having your own data type, would be to use nested functor products, since what you're describing is just a product of 4 functors. code_removed this is somewhat verbose, but you can do much better by creating your own functor product using type operators: code_removed this gets probably as terse and universal as possible.", "see also: what's so bad about lazy io?", "the code_removed version is probably better anyway, and code_removed was slightly more obvious to me. eh, i'll edit it in. i have no idea where pure is from, so.", "@david: isn't that too much of philosophy and that too, esoteric one?:| moreover, using such esoteric philosophy, even imperative programming can be called functional programming.", "@pigworker: the irritating thing here is that the induction involved is clearly within ghc's capability to understand, but the usual approach of brazenly asserting an inductive step knowing that ghc will be able to figure things out at the call site fails because class constraints must be satisfied at the instance. in a way, this forces us to actually prove the inductive step itself, rather than treating it as advice to ghc on how to prove arbitrary specific cases on its own. should be possible, with enough hand-holding to walk ghc through it.", "but you should have used code_removed and code_removed or similar in order to not pretend that the record selectors are unused.", "yes, i knew that idiom from erlang and its guard expressions restriction:) but that gets really ugly when the number of guards increase...", "i got a similar message from trying the lyah \"for a few monads more\" using the online haskell editor in repl.it i changed the import from: code_removed to: code_removed so my code now works looking like this (with inspiration from kwang's haskell blog): code_removed code is currently runable here", "oops, i read too fast, and only noticed the part about code_removed vs code_removed. thanks!", "ah, i that -- no, th won't work without the bytecode interpreter, but that's distinct from (though relevant to) ghci. i wouldn't be surprised if there was a perfect relation between availability of ghci and availability of the bytecode interpreter, given that ghci does depend on the bytecode interpreter, but the problem there is the lack of the bytecode interpreter, not the lack of ghci specifically.", "aargh, total failure on my part, try again...", "monads are to control flow what abstract data types are to data. in other words, many developers are comfortable with the idea of sets, lists, dictionaries (or hashes, or maps), and trees. within those data types there are many special cases (for instance insertionorderpreservingidentityhashmap). however, when confronted with program \"flow\" many developers haven't been exposed to many more constructs than if, switch/case, do, while, goto (grr), and (maybe) closures. so, a monad is simply a control flow construct. a better phrase to replace monad would be 'control type'. as such, a monad has slots for control logic, or statements, or functions - the equivalent in data structures would be to say that some data structures allow you to add data, and remove it. for example, the \"if\" monad: code_removed at its simplest has two slots - a clause, and a block. the code_removed monad is usually built to evaluate the result of the clause, and if not false, evaluate the block. many developers are not introduced to monads when they learn 'if', and it just isn't necessary to understand monads to write effective logic. monads can become more complicated, in the same way that data structures can become more complicated, but there are many broad categories of monad that may have similar semantics, but differing implementations and syntax. of course, in the same way that data structures may be iterated over, or traversed, monads may be evaluated. compilers may or may not have support for user-defined monads. haskell certainly does. ioke has some similar capabilities, although the term monad is not used in the language.", "the problem you're having is that haskell has different functions for integer and 'fractional' division. integer division truncates, fractional division does not. so instead of code_removed you want to do code_removed what the error message actually means is that the function code_removed is part of the code_removed class. this is basically an interface that different types can implement. to get information on it fire up ghci and do code_removed the first gives you information about the function code_removed: it tells you that it is in the class code_removed. then when you code_removed it shows you all the instances for code_removed. notice that code_removed is not an instance of code_removed so you can't use code_removed with code_removed. another tip: the backticks (`) turn a function into an infix operator so code_removed is the same as code_removed", "@andrewc this is more a proof of concept, i am not coding anything to do with this.", "@dlkulp code_removed concatenates one list to another. with code_removed the first argument is of type code_removed (an arbitrary type) and the second argument is of type code_removed which is the type of lists of elements of code_removed.", "i really like explanation in terms of \"constraint-directed inference\". however, your solution doesn't get you that: the whole point in that situation is that you don't know which constraints are satisfied for your polymorphic type, so you can't possibly wrap it in the correct code_removed to get the instance you want.", "so is there no deeper technical reason?", "you wrote code_removed. did you forget the type parameter here - code_removed?", "@vektorweg most of the work on the wikibook so far was done in the introductory chapters (which roughly cover the same ground as lyah level, though with a different take) and in the coverage of more advanced theory and type system topics. for applied issues, as seen in the later chapters of rwh swang refers to, rwh is a better choice for now; even though, as a wikibook contributor, i hope that will change eventually:)", "another use is to implement class member functions that have a dummy argument which should not be evaluated (used to resolve ambiguous types). example that could be in data.bits: code_removed by using const we explicitly say that we are defining constant values. personally i dislike the use of dummy parameters, but if they are used in a class then this is a rather nice way of writing instances.", "@pavel: i was using \"security\" in a more general sense: it's a matter of my personal safety in programming, i.e. it takes me by the hand and acts as a guard rail to keep me from falling off type-related cliffs. see also: security blanket:)", "i'm afraid this does very much fit in the \"i'm having more trouble than i expected driving my new aeroplane around the carpark\" category of problems. in reality, a list isn't the best way of storing non-homogenous data, in very much the same way that an iterator isn't the easiest way to produce it. it's not impossible, it's just inconvenient because it's the wrong tool. why not use a record for the disparate bits and lists only for when you have multiples of exactly the same thing?", "i find myself doing more and more scripting in haskell. but there are some cases where i'm really not sure of how to do it \"right\". e.g. copy a directory recursively (a la unix code_removed). since i mostly use linux and mac os i usually cheat: code_removed but what is the recommended way to copy a directory in a platform independent fashion? i didn't find anything suitable on hackage. this is my rather naiv implementation i use so far: code_removed any suggestions of what really is the way to do it? i updated this with the suggestions of hammar and fuzxxl....but still it feels kind of clumsy to me for such a common task!", "@alexandrec. i'd disagree on that, it's not a good example. mathematically, such a data structure does form a functor. the fact that we cannot implement code_removed is just a language/implementation issue. also, it's possible to wrap code_removed into the continuation monad, which makes a monad out of it with all the properties we'd expect, see this question (although i'm not sure if it can be done efficiently).", "@joachimbreitner just finished doing that. had to learn template haskell. still testing my answer, but it seems a lot faster (similar to the other question).", "this code looks like it can be fused into a loop, but when i look at the core output, the call of code_removed generates a list. that is probably why ghc is slower.", "i am having problem in entering multi-line commands in ghci. the following 2-line code works from a file: code_removed but when i enter in ghci, i get errors. i also tried putting the code inside code_removed, but they are also not working for this example, because this is just appending the lines into one line, which should not be the case. i am using winghci, version 2011.2.0.1", "you can change directory via code_removed load another file/module. it causes the preceding module to unload. see the definition of:cd/:load in", "also i disagree with your conclusion about why monads are hard. if monads themselves aren't complex, then you should be able to explain what they are without a bunch of baggage. i don't want to know about the implementation when i ask the question \"what is a monad\", i want to know what itch it's meant to be scratching. so far it seems like the answer is \"because the authors of haskell are sadomasochists and decided that you should do something stupidly complex to accomplish simple things, so you have to learn monads to use haskell, not because they're in any way useful in themselves\"...", "it was not meant as a answer to the question - i am not familiar with the specs - i'm just saying that from a mathemtical standpoint the definition of min and max is fine. of course you cannot order nan (if you include nan there are many math. properties you throw out) - i just wanted to know if maybe the specs are a bit misleading or even self-contratictory in a sens - so never mind", "if you are looking for a good explanation of the algorithm, the best that i've found so far is in chapter 30 of shriram krishnamurthi's programming languages: application and interpretation (cc licensed!).", "in the years since this answer was written, this sentence seems to have become less true: \"higher-rank types (forall to the left of an arrow) are rarely found in the wild.\" the trick code_removed uses to prevent unsafe usage is now reasonably common: see code_removed in code_removed, for example.", "a great way to learn more about anything (any function) is to remember that everything is a function! that general mantra helps, but in specific cases like operators, it helps to remember this little trick: code_removed and code_removed just remember to use code_removed liberally, and wrap your operators in code_removed!", "this is one of the most valuable things i've ever seen on stack overflow! @c.a.mccann: thank you for the clarification. it was much appreciated here.", "haskell has an identity function which returns the input unchanged. the definition is simple: code_removed so for fun, this should output code_removed: code_removed after a few seconds (and about 2 gb of memory according to task manager), compilation fails with code_removed. similarly, the interpreter says code_removed. since code_removed is a pretty simple function, i wouldn't expect it to be a memory burden at run time or compile time. what is all the memory being used for?", "i thought this was a great introduction for someone who wants to learn about functional programming. it doesn't have good practice problems, and it takes the reader a long time to get to the point at which they can make useful things with haskell.", "i do see why the first list of items very vaguely feel like they have various levels of (un)definedness -- i'm not trying to be difficult -- but i'd like to know if there's more to this since the answer says this comes from mathematical theory.", "++ high-quality, in-depth, comprehensive answer.", "@john l: well, if it's slow because ghc is doing more linking than necessary with a linker that's slower than necessary, there are two obvious ways to improve the overall result, but only one that doesn't require messing with ghc's internals.;]", "ghc stack related info: ghc.haskell.org/trac/ghc/wiki/commentary/compiler/stackareas", "my understanding has grown and i've been contemplating a rewrite of the above. due to this current activity i think i may do so soon. @gabriel the concept of monads is a concept in functional programming irrespective of its place or origin in mathematics.", "what do you mean by \"standard\" version?", "code_removed is the loop. its implementation depends on the data structure to be traversed. that might be a list, tree, code_removed, code_removed(uence), or anything that has a generic way of being traversed via something like a for-loop or recursive function. an array would have a for-loop, a list a while-loop, a tree either something recursive or the combination of a stack with a while-loop; but in functional languages you do not need these cumbersome loop commands: you combine the inner part of the loop (in the shape of a function) with the data structure in a more directly manner and less verbose. with the code_removed typeclass, you could probably write your algorithms more independent and versatile. but my experience says, that code_removed is usually only used to simply glue algorithms to existing data structures. it is quite nice not to need to write similar functions for different datatypes qualified, too.", "not the most efficient way, but does memoize: code_removed when requesting code_removed, it is checked that code_removed exists, but its exact value is not calculated. it's still set as some unknown result of a calculation. the only exact values calculated are the ones needed. so initially, as far as how much has been calculated, the program knows nothing. code_removed when we make the request code_removed, it starts doing some pattern matching: code_removed now it starts calculating code_removed this recursively makes another demand on f, so we calculate code_removed now we can trickle back up some code_removed which means the program now knows: code_removed continuing to trickle up: code_removed which means the program now knows: code_removed now we continue with our calculation of code_removed: code_removed which means the program now knows: code_removed now we continue with our calculation of code_removed: code_removed which means the program now knows: code_removed so the calculation is done fairly lazily. the program knows that some value for code_removed exists, that it's equal to code_removed, but it has no idea what code_removed is.", "@abababa22 i think reading lyah first and then going to rwh is the best idea. lyah doesn't teach you just haskell; it teaches you functional programming. you begin thinking in functional way when you solve problems. clearly, only lyah wouldn't be enough to write a large application, but it bends your mind the right way. if you're from imperative background, this is the best way, imo", "...except, that won't let the op declare a custom code_removed version. also, it won't allow a declaration of code_removed for a type that is not (yet) a show instance.", "given your description, i would suggest ocaml or f#. the ml family are generally very good in terms of a strong type system. the emphasis on recursion, coupled with pattern matching, is also clear. where i am a bit hesitant is on the rewarding to learn part. learning them was rewarding for me, no doubt. but given your restrictions and your description of what you want, it seems you are not actually looking for something much more different than haskell. if you didn't put your restrictions i would have suggested python or erlang, both of which would take you out of your comfort zone.", "checking this answer shared above by the author, and seeing that in data.foldable code_removed instance has a function such as code_removed, my current understanding is that, somehow, a 2-tuple is converted to a list that has the tuple's last item, and in turn, functions such as code_removed and code_removed is applied to that list. this seems to answer \"how?\". the \"why?\" is still not clear for me (and apparently there's some controversy (?))", "you can't find (:) on hoogle. why not?", "jorg: sounds exciting. can you give me an example of a functional operating system?", "can you post the \"core\", i.e. run code_removed on both functions?", "@semicon the difference for languages like java is the existence of mature, well-tested and fully-automated tools for refactoring. generally these tools have fantastic editor integration, and take away a huge amount of the tedious work associated with refactoring. haskell gives us a brilliant type system with which to detect things that must be changed in a refactoring, but the tools to actually carry out that refactoring are (at the present moment) very limited, especially compared to what has already been available in the java ecosystem for more than 10 years.", "@lirik, well, i guess by pronounce i mean \"whaddya call this thing\":) @chuck, post your code_removed suggestion as an answer and i'll upvote you", "in many articles about haskell they say it allows to make some checks during compile time instead of run time. so, i want to implement the simplest check possible - allow a function to be called only on integers greater than zero. how can i do it?", "since i wrote this answer the rust programming language has increased in popularity by quite a bit. so it's worth mentioning that rust uses a linear-ish type system for controlling access to memory and it's worth having a look at if you want to see the ideas i mentioned used in practice.", "i managed to found this new download link: pau-za.cz/data/2/sprava.pdf", "in the 2009-2012 period, the following things have happened: 2012: from 2012, the parallel haskell status updates began appearing in the parallel haskell digest. 2011: parallel and concurrent programming in haskell, a tutorial. version 1.1 released by simon marlow haskell and parallelism, mentioned in an article in the economist magazine, jun 2nd 2011. parallel tree scans via composition, an article by conal elliott numeric haskell, a tutorial on parallel array programming with repa, released works has begun on extending ghc eventlog and threadscope to support multi-process or distributed haskell systems parallel haskell digest: edition 2. the par-monad package and a monad for deterministic parallelism, simon marlow -- more control over pure parallelism than strategies/par/pseq. cloud haskell: erlang-style message passing between distributed haskell nodes. parallel haskell: embracing diversity, a talk by spj. real time edge detection in parallel haskell parallel haskell digest: news on parallel haskell composable parallel scanning haskell-mpi is released 2010: parallel futures for haskell, in ghc. the orc language, for concurrent job scheduling and scripting, was released. a new scalable thread event manager was merged into ghc. an improved approach to parallel sparks and strategies was developed. the nikola edsl for embedding gpu programs in haskell was developed. the llvm backend for ghc was merged in, with good performance improvements. ghc 6.12.x series: with parallel performance improvements microsoft announces 2 years of funding to support commercial users of parallel haskell google published their experience report on the use of haskell (pdf) intel announced the concurrent collections for haskell library, including scalability numbers -- scaling results for 32 and 48 cores sun/oracle bought us a machine and funded work on improving parallel performance. recent updates to the status of data parallelism in haskell msr released threadscope, a graphical profiler for parallel haskell programs the ghc runtime got extensively tuned for sparks and futures there was a good discussion on additional ways to improve parallel performance a collection of reading material on parallelism in haskell to help you get started the snap guys are getting 45k req/sec on their 4 way box, by using all the cores. even the erlang guys are taking notice. meanwhile, there is work to make the io manager more scalable -- now with a paper on the design:: pdf. we're out there teaching people too.. all.. over.. the... place. starling software wrote about their real time, multicore financial trading system in haskell. ericsson published a parallel language for dsp based on, and written in haskell galois published an implementation of orc, a concurrent workflow language, in haskell. and a new library for fast regular, parallel arrays appeared and haskell continues to do well on the quad-core shootout. snap, a multicore-enabled scalable web server with great performance numbers haskell-torrent - benchmarking a mulitcore-enabled bittorrent client in haskell haskell code was published at supercomputing 09 -- our first appearance at sc!", "awesome answer. helped me out a ton. i really appreciate your time and i think i'm finally coming to grips with the laziness.", "are you saying that 1+1 and pair(1,2) + pair(2,3) cannot exist in the same file at the same time?", "perhaps a thought experiment will de-mystify this extension a bit. let's pretend that we've dropped the restriction that functions defined with multiple pattern cases must be all in one place, so that you can write code_removed at the top of a module, and then have cases like code_removed elsewhere. in fact, let's go even further, and allow cases to be defined in different modules entirely! if you think that sounds like it would be confusing and error-prone to use, you're correct. to recover some semblance of sanity, we could add some limitations. for instance (ha, ha), we could require the following properties to hold: anywhere such a function is used, the arguments given must match exactly one pattern. anything else is a compiler error. adding new patterns (including by importing another module) should never change the meaning of valid code--either the same patterns are chosen, or a compiler error is produced. it should be clear that matching simple constructors like code_removed or code_removed is straightforward. we also can handwave things a bit and assume that the compiler can disambiguate literals, like code_removed and code_removed above. on the other hand, binding arguments with patterns like code_removed becomes awkward--writing such a pattern means giving up the ability to write patterns like code_removed or code_removed later, since that would create ambiguity. worse yet, pattern guards become nearly useless, because they need very general matches. many common idioms will produce endless ambiguity headaches, and of course writing a \"default\" fall-through pattern is completely impossible. this is roughly the situation with type class instances. we could regain some expressive power by relaxing the required properties as such: anywhere such a function is used, it must match at least one pattern. no matches is a compiler error. if a function is used such that multiple patterns match, the most specific pattern will be used. if there is no unique most specific pattern, an error is produced. if a function is used in a way that matches a general instance, but could be applied at run-time to arguments that would match a more specific instance, this is a compiler error. note that we are now in a situation where merely importing a module can change the behavior of a function, by bringing into scope a new, more specific pattern. things might get murky in complicated cases involving higher-order functions, as well. still, in many cases problems are unlikely--say, defining a generic fall-through pattern in a library, while letting client code add specific cases if needed. that's roughly where code_removed puts you. as suggested in the example above, if creating new overlaps is always either impossible or desired, and different modules won't end up seeing different, conflicting instances, then it's probably fine. what it really comes down to is that the limitations removed by code_removed are there to make using type classes behave sensibly under the \"open world\" assumption that any possible instance could later be added. by relaxing those requirements, you're taking on that burden yourself; so think through all the ways that new instances could be added and whether any of those scenarios are a significant problem. if you're convinced that nothing will break even in obscure and devious corner cases, then go ahead and use the extension.", "@btk: everyone has to stop being a beginner at some point. i started learning haskell yesterday and i am confident that within a short time, i will understand everything raeez says.", "it's o(n^2) unfortunately.", "how can there be more than two levels of definedness (i.e. defined and undefined)?", "thanks guys - that makes me happy!", "nice! thank you!", "ah, i see what you're saying. this is what natty is for, like in vreplicate where we do different things depending on n. indeed this can get a little clunky. an alternative to the cps style is to work with packed up existentials: code_removed.", "can maybe's type be code_removed? since code_removed is still a type constructor, does that mean it's impossible to write in the data-context, code_removed? because that would make the data ambiguous? and when you say \"where a type is expected\", that means in stuff like type signatures, declarations, data/newtype/type.. etc. but not in the actual \"code\", such as variable assignment, function application.. etc.", "you could do this using existential types, but how would you get the values back out of the resulting list?", "and one way to accomplish that would be to pattern match code_removed (before any other code_removed match that would have triggered evaluation of code_removed). right?", "haskell also allows you to omit those signatures completely. this is no worse.", "i find this comment interesting: \"make sure that your refactorings will cause type errors until complete.\"", "i came to this post by way of better understanding the inference of the infamous quote from mac lane's category theory for the working mathematician. in describing what something is, it's often equally useful to describe what it's not. the fact that mac lane uses the description to describe a monad, one might imply that it describes something unique to monads. bear with me. to develop a broader understanding of the statement, i believe it needs to be made clear that he is not describing something that is unique to monads; the statement equally describes applicative and arrows among others. for the same reason we can have two monoids on int (sum and product), we can have several monoids on x in the category of endofunctors. but there is even more to the similarities. both monad and applicative meet the criteria: endo => any arrow, or morphism that starts and ends in the same place functor => any arrow, or morphism between two categories (e.g., in day to day code_removed, but in category code_removed) monoid => single object; i.e., a single type, but in this context, only in regards to the external layer; so, we can't have code_removed, only code_removed. the statement uses \"category of...\" this defines the scope of the statement. as an example, the functor category describes the scope of code_removed, i.e., code_removed, e.g., code_removed or code_removed. what a categorical statement does not specify describes where anything and everything is permitted. in this case, inside the functors, code_removed aka code_removed is not specified which means code_removed. as my imagination jumps to int -> string, it also includes code_removed, or even code_removed where code_removed. so the statement comes together as follows: functor scope code_removed (i.e., any parameterized type to any parameterized type) endo + functor code_removed (i.e., any one parameterized type to the same parameterized type)... said differently, a monoid in the category of endofunctor so, where is the power of this construct? to appreciate the full dynamics, i needed to see that the typical drawings of a monoid (single object with what looks like an identity arrow, code_removed), fails to illustrate that i'm permitted to use an arrow parameterized with any number of monoid values, from the one type object permitted in monoid. the endo, ~ identity arrow definition of equivalence ignores the functor's type value and both the type and value of the most inner, \"payload\" layer. thus, equivalence returns code_removed in any situation where the functorial types match (e.g., code_removed is equivalent to code_removed because they are both code_removed). sidebar: ~ outside is conceptual, but is the left most symbol in code_removed. it also describes what \"haskell\" reads-in first (big picture); so type is \"outside\" in relation to a type value. the relationship between layers (a chain of references) in programming is not easy to relate in category. the category of set is used to describe types (int, strings, maybe int etc.) which includes the category of functor (parameterized types). the reference chain: functor type, functor values (elements of that functor's set, e.g., nothing, just), and in turn, everything else each functor value points to. in category the relationship is described differently, e.g., code_removed is considered a natural transformation from one functor to another functor, different from anything mentioned thus far. back to the main thread, all in all, for any defined tensor product and a neutral value, the statement ends up describing an amazingly powerful computational construct born from its paradoxical structure: on the outside it appears as a single object (e.g., code_removed); static but inside, permits a lot of dynamics any number of values of the same type (e.g., empty | ~nonempty) as fodder to functions of any arity. the tensor product will reduce any number of inputs to a single value... for the external layer (~code_removed that says nothing about the payload) infinite range of both the type and values for the inner most layer in haskell, clarifying the applicability of the statement is important. the power and versatility of this construct, has absolutely nothing to do with a monad per se. in other words, the construct does not rely on what makes a monad unique. when trying to figure out whether to build code with a shared context to support computations that depend on each other, versus computations that can be run in parallel, this infamous statement, with as much as it describes, is not a contrast between the choice of applicative, arrows and monads, but rather is a description of how much they are the same. for the decision at hand, the statement is moot. this is often misunderstood. the statement goes on to describe code_removed as the tensor product for the monoidal endofunctor. however, it does not articulate how, in the context of this statement, code_removed could also have also been chosen. it truly is a an example of six/half dozen. the logic for combining values are exactly alike; same input generates the same output from each (unlike the sum and product monoids for int because they generate different results when combining ints). so, to recap: a monoid in the category of endofunctors describes: code_removed code_removed and code_removed both provide simultaneous access to the two code_removed values in order to compute the the single return value. the logic used to compute the return value is exactly the same. if it were not for the different shapes of the functions they parameterize (code_removed versus code_removed) and the position of the parameter with the same return type of the computation (i.e., code_removed versus code_removed for each respectively), i suspect we could have parameterized the monoidal logic, the tensor product, for reuse in both definitions. as an exercise to make the point, try and implement code_removed, and you end up with code_removed and code_removed depending on how you decide to define it code_removed. if my last point is at minimum conceptually true, it then explains the precise, and only computational difference between applicative and monad: the functions they parameterize. in other words, the difference is external to the implementation of these type classes. in conclusion, in my own experience, mac lane's infamous quote provided a great \"goto\" meme, a guidepost for me to reference while navigating my way through category to better understand the idioms used in haskell. it succeeds at capturing the scope of a powerful computing capacity made wonderfully accessible in haskell. however, there is irony in how i first misunderstood the statement's applicability outside of the monad, and what i hope conveyed here. everything that it describes turns out to be what is similar between applicative and monads (and arrows among others). what it doesn't say is precisely the small but useful distinction between them. - e", "in addition to what other's have already mentioned, having side-effecting actions be first-class is sometimes useful. here's a silly example to show the idea: code_removed this example shows how you can build up computations with side-effects (in this example code_removed) and then put the in data structures or manipulate them in other ways, before actually executing them.", "true, but programmers isn't only a site for subjective questions. it is a place for questions that aren't directly related to code e.g. language choice. good question though. +1", "just a wild guess, but maybe it's related to stream fusion? in the first example, it's easier for ghc to see that ts' is constructed using tovector, while in the second example, ghc would have to inline bind to see that.", "another odd thing is that if i ask ghci code_removed, it tells me code_removed, but if i ask code_removed, it tells me code_removed. so something seems to be very strange about how the parser handles code_removed.", "\"applicative is almost the same as monads, except that effects cannot depend on previous results.\"... a lot of stuff clicked into place for me with this line, thanks!", "@c.a.mccann: right. i think i prefer code_removed, since it can be related to that version easily, and doesn't explicitly use \"indices\" (not really indices in this case, but still) into lists, which tend to be a bad sign imo. but both seem useful. (i think my favourite replacement would be code_removed, since code_removed is already doing the work you need for code_removed too, and they often come in pairs; plus it doesn't throw any information away, which is nice.)", "yes, you can, using the code_removed extension. code_removed note that this pattern will always succeed, though, so you'll probably want to add a pattern for the case where the list is empty, else code_removed will throw an exception. code_removed also note that this is just syntactic sugar. unlike normal pattern matching, this is o(n), since you're still accessing the last element of a singly-linked list. if you need more efficient access, consider using a different data structure such as code_removed, which offers o(1) access to both ends.", "i was reading through the announcement of classyprelude and got to here: code_removed the writer then mentioned that this would not work: code_removed which makes sense to me, as code_removed is completely unrelated to the constraint on the left. however, what isn't mentioned in the article and what i don't understand is why this wouldn't work: code_removed could someone explain why this is different to the first mentioned definition? perhaps a worked example of ghc type inference would be helpful?", "@pelotom well if that's true then they can be replaced with values, no? or does the laziness make this impossible?", "see haskell's overlooked object system by oleg kiselyov and ralf laemmel for a detailed explanation of how oo concepts can be implemented in haskell. but as antal said in the comments, don't try to write a java program in haskell. remember that objects are a poor man's closure, and closures are a poor man's object.", "@savui i think the point is that code_removed constructors are naturally lazy in haskell. implementing the optimization that single-argument single-constructor data-types are represented identically to the single argument of the single constructor would change program behaviour. optimizations that change behaviour aren't really just optimizations; they're changes to the meaning of the language. mercury actually has this optimization, because it is a strict language and so there this doesn't change behaviour.", "off the top of my head; data declarations use lazy evaluation in access and storage of their \"members\", whereas newtype does not. newtype also strips away all previous type instances from its components, effectively hiding its implementation; whereas data leaves the implementation open. i tend to use newtype's when avoiding boilerplate code in complex data types where i don't necessarily need access to the internals when using them. this speeds up both compilation and execution, and reduces code complexity where the new type is used. when first reading about this i found this chapter of a gentle introduction to haskell rather intuitive.", "@aavogt tgeeky was working on fixing it up, but i don't think he finished: github.com/technogeeky/zeroth if noone does it / make something for this, i'll get around to it eventually.", "the two haskell web frameworks in the news recently are yesod (at 0.8) and snap (at 0.4). it's quite obvious that yesod currently supports a lot more features than snap. however, i can't stand the syntax yesod uses for its html, css and javascript. so, i'd like to understand what i'd be missing if i went with snap instead. for example, doesn't look like database support is there. how about sessions? other features?", "son of a... somebody actually did it! kudos.", "anybody looking at this answer should be aware that node can easily process 100k simple requests on a single core and it's trivially easy to scale a stateless node application across many cores. code_removed will automatically scale to the optimum number of instances based on cores available. additionally, node is also non-blocking by default.", "@semicolon my comment was a bit tongue-in-cheek. however, there is some truth to it as well: code_removed hides a call to code_removed in a way that makes it easy to forget it's there, which can cause surprising runtimes and surprising behavior; also, because of the simplistic type of code_removed it is very tempting to write instances that do bad things like choose a terrible encoding or do some parsing when you aren't expecting it, and this temptation can also cause subtle bugs. generally: \"explicit is better\".", "agree on the dupe, though the titles of both questions make them look subjective & argumentative. i'm not sure it's a good idea to edit the title of a 6-month-old question though.", "paul's and yairchu's are both good explanations. i'd like to add that the function being lifted can have an arbitrary number of arguments and that they don't have to be of the same type. for example, you could also define a liftfoo1: code_removed in general, the lifting of functions that take 1 argument is captured in the type class code_removed, and the lifting operation is called code_removed: code_removed note the similarity with code_removed's type. in fact, if you have code_removed, you can make code_removed an instance of code_removed: code_removed furthermore, the generalization of lifting to an arbitrary number of arguments is called applicative style. don't bother diving into this until you grasp the lifting of functions with a fixed number of arguments. but when you do, learn you a haskell has a good chapter on this. the typeclassopedia is another good document that describes functor and applicative (as well as other type classes; scroll down to the right chapter in that document). hope this helps!", "the key are the records: notice code_removed, code_removed. whenever we lookup a variable from the environment, we actually get back a record, which we dereference to see if it's a thunk. if it is a thunk, we evaluate it and then save the result. we create thunks during application (notice the call to the code_removed constructor), recursive definitions and pattern matching, because those are constructs that bind variables.", "i'm going to be that guy and suggest that you're asking for the wrong thing. first you say that you want to broaden your horizons. then you describe the kind of language that you want, and its horizons sound incredibly like the horizons you already have. you're not going to gain very much by learning the same thing over and over. i would suggest you learn a lisp \u2014 i.e. common lisp, scheme/racket or clojure. they're all dynamically typed by default, but feature some sort of type hinting or optional static typing. racket and clojure are probably your best bets. clojure is more recent and has more haskellisms like immutability by default and lots of lazy evaluation, but it's based on the java virtual machine, which means it has some odd warts (e.g. the jvm doesn't support tail call elimination, so recursion is kind of a hack). racket is much older, but has picked up a lot of power along the way, such as static type support and a focus on functional programming. i think you'd probably get the most out of racket. the macro systems in lisps are very interesting and vastly more powerful than anything you'll see anywhere else. that alone is worth at least looking at.", "s f g x = s x (g x) should be s f g x = f x (g x)", "it's a type of kind code_removed just like code_removed, code_removed or code_removed. it just happens to have 0 values instead of 1 or 2 or more. it's not a hack but rather a fundamental part of haskell's type system. it plays the role of 0 to code_removed's 1 and, if we look at types as propositions, code_removed corresponds to the proposition \"false\". it's also an identity to sum types (code_removed) just like code_removed is an identity to product types: code_removed is isomorphic to code_removed. in practice, it often acts as a dual of code_removed; the best example of this i've seen is in pipes where code_removed is used to tag things that don't take inputs and code_removed (named code_removed) is used to tag things that don't produce outputs. (see appendix:types in the tutorial.) it is a way to mark things as impossible or missing, but it is by no means a hack.", "to derive an instance, the syntax is code_removed so here, for instance, you'd have code_removed there's no precondition; you'd use that for something like code_removed, which says that if code_removed is showable, then so is code_removed. here, all code_removed are showable, so there's nothing to worry about. when you wrote code_removed, you made a few mistakes. first, code_removed implies that code_removed is a parametrized type (one declared by, for instance, code_removed), which it isn't. second, code_removed implies that if code_removed is showable, then you want to declare some other instance. and third, after the code_removed, having a function is nonsensical\u2014haskell wanted a type class name. also, for completeness's sake, there's another way to derive code_removed if you want the code_removed format for displayed output: code_removed as specified in the haskell 98 report, there are only a handful of types which can be derived this way: code_removed, code_removed, code_removed, code_removed, code_removed, and code_removed. with the appropriate ghc extensions, you can also derive code_removed, code_removed, code_removed, code_removed, and code_removed; you can derive any class which a code_removed's wrapped type derived for a code_removed; and you can generate these automatic instances in a standalone way.", "there is also code_removed which brings some standard concatenative combinators into haskell. your examples could just as well be code_removed and code_removed. it doesn\u2019t necessarily show here, but code_removed does help improve legibility for a lot of point-free expressions, because, well, that\u2019s what concatenative programming is all about.", "davorak: but this way i get double the points for the same answer. seriously though, i forgot about that previous question. perhaps so should have a better filter process for repeat questions - we've been getting a lot of those lately and they really don't add any value.", "@ftor i see what you are saying, sorry! that's a really good observation that probably warrants its own so question. i understand it this way: there are two levels of \"determine concrete type based on context\". one level \u2013 type classes \u2013 determine concrete type based on run-time context. the other level \u2013 type inference \u2013 which is the one involved in the code_removed case, uses information known statically. the compiler picks a type for code_removed depending on context, but this type is merely a compile time annotation of sorts. it still uses the same code_removed for all cases. so yes and no?:d", "you should have a look at graph reduction using combinators (ski). it's beautiful and simple and illustrates how lazy evaluation works.", "+1 also see my comment on larsmans's answer. but be careful to advertise python as rather functional. for example, generator expressions are usually preferred over code_removed, code_removed, etc. but still, generators and generator expressions will feel familiar to someone who knows lazy evaluation and the said functions.", "there is the type code_removed from code_removed which can hold anything (well, anything code_removed). but that is rarely the right way to do it. what is the problem that you are trying to solve?", "that code_removed instance itself is extremely obscure.", "that's great guidance; thank you!", "this was going to be my answer. i briefly gave pause to think about efficiency though - i use the code_removed pattern a lot, but i wonder how expensive the conversions to and from code_removed are compared to walking over the list and grouping manually.", "please let me know if this is an unconstructive question.", "+1 wow, been using haskell for years and never noticed that such definition is not allowed!", "just as nodejs has dropped libev the snap haskell web framework has dropped libev too.", "to specify only the type of an argument, you can write something like code_removed so that it is easy to later amend it like, e.g., code_removed and have its inferred type change accordingly: code_removed you could use the same contorted technique to specify the return type of a function, perhaps defined in pointfree style, but this is not pretty. code_removed it is also not much different from what you have right now, just keeps the code and the type spec separated.", "@musikk many years later searching for [a] -> int -> maybe a on hoogle returns 0 results that meet the signature i.imgur.com/3xgh1m8.png while searching on hayoo returns a lot of examples that meet it. i.imgur.com/anlnirp.png", "it may be important to take a look how indexing is used in dependent types (eg in agda). this can explain how indexing helps in general, then translate this experience to monads. indexing permits to establish relationships between particular instances of types. then you can reason about some values to establish whether that relationship holds. for example (in agda) you can specify that some natural numbers are related with code_removed, and the type tells which numbers they are. then you can require that some function is given a witness that code_removed, because only then the function works correctly - and without providing such witness the program will not compile. as another example, given enough perseverance and compiler support for your chosen language, you could encode that the function assumes that a certain list is sorted. indexed monads permit to encode some of what dependent type systems do, to manage side effects more precisely.", "this is the video you are looking for. demonstrating in c# what the problem is with composition and aligning the types, and then implementing them properly in c#. towards the end he displays how the same c# code looks in f# and finally in haskell.", "thanks, i have to check out this module...", "umm i spent over a year now thinking about haskell and i still can't confidently understand what a functor is(is it a function object? an object you can map over? a function taking a and returning m a? a binary function taking a and returning m a? how can you map over a function if it has no elements to iterate over...) let alone what an endofunctor is. i understand that fmap lets you apply a function on a boxed object, and >>= lets you push a boxed object of m into a function a -> m a, but what now?", "darcs is an open source, source code management system. it should give you a nice idea for haskell.", "why use code_removed rather than tuples, i.e. code_removed)?", "contribute to ghc!", "function execution time benchmark is included in criterion.measurement for example, if i want to capture the time of code_removed code_removed", "it's a bit orthogonal to your question, but you can pull off these proofs by using a set of equational reasoning combinators \u00e0 la agda. cf. this proof of concept", "i do think that realizing haskell's feature by examples is the best way to start above all. here is tricky typeclasses including monads and arrows for real world problems and bigger project, remember these tags: ghc(most used compiler), hackage(librarydb), cabal(building system), darcs(another building system). a integrated system can save your time: the package database for this system: ghc compiler's wiki: after haskell_98_features and typeclassopedia, i think you already can find and read the documention about them yourself by the way, you may want to test some ghc's languages extension which may be a part of haskell standard in the future. this is my best way for learning haskell. i hope it can help you.", "i have edited my answer to better explain the idea, as suggested by @hammar.", "@duplode yes, thank you - i have updated the answer. actually, a code_removed instance can be defined for any sum of any number of product of any number of code_removeds, and possibly in more than one way. the practical usefulness of any of these monads remains to be determined. for example, what could be a use case for something like code_removed?", "isn't it code_removed? using code_removed instead of code_removed.", "put simply, you can write types that depend on terms (calculations). this is enough to specify types about every aspect of your program, and therefore means the type system is capable of full program specification. the problem is that because the types depend on calculations, type checking is vastly more difficult to do (impossible in general).", "@c.a.mccann: i absolutely agree that code_removed is darn ugly. however, i have never tried to avoid every single partial function, always thought it would just blow up the code unnecessarily. maybe this is because i come from an imperative background:p", "whoa...it's so...imperative.:)", "also related: uses for newtype: stackoverflow.com/questions/991467/\u2026", "what you've described can't be done in pure functional code. pure functional code implies that you will get the same output for the same input, every time. since a randomizing function, by definition, gives you different output for the same input, this is impossible in pure functional code. unless you pass around an extra value as explained in @camccann's answer. technically, it doesn't even have to be as advanced as an rng, depending on your needs. you could pass around an integer, and multiply it by 10 and subtract 3 (or whatever), then take the modulo of that to find your index. then your function remains pure, but you do directly control the randomness. another option is to use code_removed to generate a number in a range, which you can then use to select an index from the list. this will require you to enter the io monad.", "a monad is, effectively, a form of \"type operator\". it will do three things. first it will \"wrap\" (or otherwise convert) a value of one type into another type (typically called a \"monadic type\"). secondly it will make all the operations (or functions) available on the underlying type available on the monadic type. finally it will provide support for combining its self with another monad to produce a composite monad. the \"maybe monad\" is essentially the equivalent of \"nullable types\" in visual basic / c#. it takes a non nullable type \"t\" and converts it into a \"nullable<t>\", and then defines what all the binary operators mean on a nullable<t>. side effects are represented simillarly. a structure is created that holds descriptions of side effects alongside a function's return value. the \"lifted\" operations then copy around side effects as values are passed between functions. they are called \"monads\" rather than the easier-to-grasp name of \"type operators\" for several reasons: monads have restrictions on what they can do (see the definiton for details). those restrictions, along with the fact that there are three operations involved, conform to the structure of something called a monad in category theory, which is an obscure branch of mathematics. they were designed by proponents of \"pure\" functional languages proponents of pure functional languages like obscure branches of mathematics because the math is obscure, and monads are associated with particular styles of programming, people tend to use the word monad as a sort of secret handshake. because of this no one has bothered to invest in a better name.", "glad to hear it's working now!", "the code_removed package provides recursive directory traversals, which you might be able to use to simplify your code.", "it is merely a good programming practice. since record fields labels in haskell are actually top level named functions, they pollute the module namespace. adding an underscore to the field label means that you are free to define another function with the same name.", "i've learned several languages, but now i want to choose one. the language that i most liked was haskell, which is like an interpreted language but is a compiled. what are the pros and cons of haskell?", "try using the code_removed command. it should unload all the modules. this is short for code_removed which sets the current context. you can also load arbitrary modules this way: code_removed", "@klkblake: could you please post the core with annotations? if they are also the same, you really have oversimplified the example.", "it seems that a code_removed definition is just a code_removed definition that obeys some restrictions (e.g., only one constructor), and that due to these restrictions the runtime system can handle code_removeds more efficiently. and the handling of pattern matching for undefined values is slightly different. but suppose haskell would only knew code_removed definitions, no code_removeds: couldn't the compiler find out for itself whether a given data definition obeys these restrictions, and automatically treat it more efficiently? i'm sure i'm missing out on something, there must be some deeper reason for this.", "erm... you can do that in haskell just fine, only you need of course suitable type-class constraints and polymorphic functions, otherwise it can't work. but consider code_removed.", "and the trouble is, you can't give a nice clear concrete example of that. because if you try... it's just list, or maybe, or io. which are easy to grasp, but don't necessarily help the unenlightened see the whole of monads. i think this is why they're hard; they are indeed simple enough (the number of things you have to memorise to correctly implement and use monads is far smaller than what you need to know to use classes in java, for example). but the unifying concept of monad is just very very abstract.", "you will certainly be interested by the halting problem, as applying this reasoning to memory allocation helps understand why deallocation can't be statically predicted in the general case. however there are some programs for which deallocation can be predicted, just like they are some programs that can be known to terminate without actually running them.", "@dave4420: reduced", "there is a webpage associated solely to showing the speed differences in languages. based on your data versus the shootout page, i would say that your algorithm is not as good as some of the others used in the shootout page.", "i have a very simple question: given a function accepting a char and returning a string code_removed how can one convert the char into a string? i'm confused over the two types.", "@jfritsch: however, with immutable stores you can always revert to any previous version of the store, just by keeping a pointer to it. this gives you more or less free 'undo' functionality, and lets you evaluate multiple possible edits to the store (say, if it was a game board) in parallel with no extra reasoning or locking overhead.", "beware the difference between code_removed (recursion, value--copying) and code_removed (corecursion, reference--sharing).", "thanks, i'm not using evil", "what does lco mean?", "sharon curtis and shin-cheng mu have a functional pearl using zygomorphisms to find maximally dense segments (a generalization of maximum segment sums). zygomorphisms are seemingly a good fit for sliding window problems once you are accustomed to them. i'd nominate the authors for extra credit as they've avoided the use of the fixed-point mu functor.", "@cristiangarcia, code_removed", "one thing that is really unique about haskell is that there is a mailing list exactly for beginners. go to haskell-beginners. reading books is good, but having some humans to ask is always a great resource, too. together, i think there is absolutely no reason to say \"haskell is hard to learn because there's no material on it.\" you might also want to visit #haskell at irc.freenode.net.", "it's a problem i've seen on other functional programming sites; each concept is explained in terms of other (unfamiliar) concepts until the newbie goes full circle (and round the bend). must be something to do with liking recursion.", "for testing, i rely on hunit and quickcheck properties and use the haskell test framework to collect all unit tests and all quickcheck properties automatically. disclaimer: i'm the main developer of the haskell test framework.", "haskell has algebraic data types, which very few other languages have. this is perhaps what's confusing you. in other languages, you can usually make a \"record\", \"struct\" or similar, which has a bunch of named fields that hold various different types of data. you can also sometimes make an \"enumeration\", which has a (small) set of fixed possible values (e.g., your code_removed, code_removed and code_removed). in haskell, you can combine both of these at the same time. weird, but true! why is it called \"algebraic\"? well, the nerds talk about \"sum types\" and \"product types\". for example: code_removed an code_removed value is basically either an integer or a string. so the set of all possible code_removed values is the \"sum\" of the set of all possible integer values and all possible string values. thus, nerds refer to code_removed as a \"sum type\". on the other hand: code_removed every code_removed value consists of both an integer and a string. so the set of all possible code_removed values is the cartesian product of the set of all integers and the set of all strings. the two sets are \"multiplied\" together, so this is a \"product type\". haskell's algebraic types are sum types of product types. you give a constructor multiple fields to make a product type, and you have multiple constructors to make a sum (of products). as an example of why that might be useful, suppose you have something that outputs data as either xml or json, and it takes a configuration record - but obviously, the configuration settings for xml and for json are totally different. so you might do something like this: code_removed (with some suitable fields in there, obviously.) you can't do stuff like this in normal programming languages, which is why most people aren't used to it.", "@winitzki how does associativity fail? wouldn't you get code_removed in either case?", "yes, you can, using the code_removed extension. code_removed note that this pattern will always succeed, though, so you'll probably want to add a pattern for the case where the list is empty, else code_removed will throw an exception. code_removed also note that this is just syntactic sugar. unlike normal pattern matching, this is o(n), since you're still accessing the last element of a singly-linked list. if you need more efficient access, consider using a different data structure such as code_removed, which offers o(1) access to both ends.", "last i checked haskell \"primes\" was just a huge list of precomputed primes -- no computation, just lookup. so yes, of course this will be faster, but it tells you nothing about the computational speed of deriving primes in haskell.", "in haskell code_removed is an alias for code_removed: code_removed if you just want a function that converts a single char to a string you could e.g. do code_removed if you prefer pointfree style you could also write code_removed", "@leftaroundabout my \"why\" was more like \"why make a design / naming decision that leads to such a great confusion\". i mean something like that. i think i'll need to read this and this to understand it better.", "what about input data as command line arguments:)", "i gave you your first gold badge, by up-voting your question from +99 to +100:). i found it by looking at all the questions with 99 votes, and those who posted them without a gold badge;).", "@johnl: it's clear how to do it using constraints. but in the context of theorem proving it would correspond to an assumption, not proof.", "it's true that code_removed is slow, but it doesn't help that, since ghc does static linking and tries to link in a lot of stuff, there's a lot of work for the linker to do. on my slightly old macbook with 1gb ram, code_removed will often run out of memory and start swapping.", "there's a relationship between \"transducers\", coroutines and the streaming libraries pipes, conduit.", "yes, i'm pretty sure the efficiency comment is inaccurate; even with a simple non-strict evaluation you never look \"too far\" into the list, so unless ghc pessimises this, which i doubt, everything should be fine with the first, clearer version.", "here's my take, biased towards the ecosystem. libraries arrays and array programming: code_removed code_removed code_removed numerics random numbers parallel programming the code_removed monad unicode and locales code_removed and code_removed parsing code_removed code_removed networking code_removed and/or code_removed web stuff templating persistance databases beyond code_removed no-sql storage bindings graphics code_removed code_removed code_removed xml code_removed crypto processors and systems stuff techniques generics code_removed code_removed metaprogramming template haskell data structures designing data structures edsls designing edsls memoization designing with monads tools code_removed advanced ffi tools code_removed using haskell from c tuning the runtime, esp. gc flags", "@alex your impression is correct f# is multiparadigm with emphasis on fp but you can do pure oo in f# if you so wish", "i read left and i looked, literally, left. so it was highly unclear to me until you said \"parse tree\".", "what is the difference between the dot code_removed and the dollar sign code_removed?. as i understand it, they are both syntactic sugar for not needing to use parentheses.", "it looks like you got it in! could you possibly update your answer to reflect this?", "i want to make a haskell function that can pick out a random number from a given list. my type signature is: code_removed what should i do?", "@cmcdragonkai: i don't know, and i don't think anyone does for sure. figuring out the right way to handle this stuff is something of an open question, as far as i know.", "@pauloscardine, this is nothing you have to be concerned about. my question came from the interest to understand some advanced data structure and maybe getting a glimpse of what's cutting edge in haskell development right now - it is on no way necessary or representative of what actually writing haskell is about so far. (and a heads up, it gets better once you're past the io learning stage again)", "there, deleted link.", "@kizzx2: there's a ghc ticket to have it added. from what i've understood, this transformation can result in additional allocations of closure objects. this means worse performance in some cases, but as johan tibell suggests in his blog post this can be avoided if the resulting wrapper can be inlined.", "there are some ghc extensions that are too good to live without. among my favorites are multiparameter type classes scoped type variables higher-rank types generalized algebraic data types (gadts) of these the really essential one is multiparameter type classes. some ghc extensions are very speculative and experimental, and you may want to use with caution. a good way to identify a stable and trusted extension is to see if it is slated for inclusion in haskell prime, which is hoped to be the successor the haskell 98. i second don stewart's suggestion that every extension should be marked using the code_removed pragma in the source file. don't enable extensions using command-line options.", "in your second example code_removed also has a polymorphic type. so the type at which code_removed is used isn't ambiguous; it just hasn't been chosen yet. the context where code_removed is used will determine which type's code_removed is chosen (and different use-sites can make different choices). the user of code_removed can ask it to provide any code_removed type they please; code_removed and code_removed can also provide any code_removed type, so code_removed will just ask them for exactly the type its user is asking for.", "can you explain the relationship between categories generally and kleisli categories? the three laws you describe hold in any category.", "how do i understand the hindley-milner rules? hindley-milner is a set of rules in the form of sequent calculus (not natural deduction) that says you can deduce the (most general) type of a program from the construction of the program without explicit type declarations. the symbols and notation first, let's explain the symbols \ud835\udc65 is an identifier (informally, a variable name). : means is a type of (informally, an instance of, or \"is-a\"). \ud835\udf0e (sigma) is an expression that is either a variable or function. \u2208 means is an element of \ud835\udeaa (gamma) is an environment. \u22a6 (the assertion sign) means asserts (or proves, but contextually \"asserts\" reads better.) \ud835\udeaa\u22a6 \ud835\udc65 : \ud835\udf0e is thus read \ud835\udeaa asserts \ud835\udc65, a \ud835\udf0e \ud835\udc52 is an actual instance (element) of type \ud835\udf0e. \ud835\udf0f (tau) is a type: either basic, variable (\ud835\udefc), functional \ud835\udf0f\u2192\ud835\udf0f', or product \ud835\udf0f\u00d7\ud835\udf0f' \ud835\udf0f\u2192\ud835\udf0f' is a functional type where \ud835\udf0f and \ud835\udf0f' are types. \ud835\udf06\ud835\udc65.\ud835\udc52 means \ud835\udf06 (lambda) is an anonymous function that takes an argument, \ud835\udc65, and returns an expression, \ud835\udc52. let \ud835\udc65 = \ud835\udc52\u2080 in \ud835\udc52\u2081 means in expression, \ud835\udc52\u2081, substitute \ud835\udc52\u2080 wherever \ud835\udc65 appears. \u2291 means the prior element is a subtype (informally - subclass) of the latter element. \ud835\udefc is a type variable. \u2200 \ud835\udefc.\ud835\udf0e is a type, \u2200 (for all) argument variables, \ud835\udefc, returning \ud835\udf0e expression \u2209 free(\ud835\udeaa) means not an element of the free type variables of \ud835\udeaa defined in the outer context. (bound variables are substitutable.) everything above the line is the premise, everything below is the conclusion (per martin-l\u00f6f) what follows here are english interpretations of the logic statements, followed by an explanation. variable given \ud835\udc65 is a type of \ud835\udf0e (sigma), an element of \ud835\udeaa (gamma), conclude \ud835\udeaa asserts \ud835\udc65 is a \ud835\udf0e. this is basically a tautology - an identifier name is a variable or a function. function application given \ud835\udeaa asserts \ud835\udc52\u2080 is a functional type and \ud835\udeaa asserts \ud835\udc52\u2081 is a \ud835\udf0f conclude \ud835\udeaa asserts applying function \ud835\udc52\u2080 to \ud835\udc52\u2081 is a type \ud835\udf0f' this means that if we know that a function returns a type, and we apply it to an argument, the result will be an instance of the type we know it returns. function abstraction given \ud835\udeaa and \ud835\udc65 of type \ud835\udf0f asserts \ud835\udc52 is a type, \ud835\udf0f' conclude \ud835\udeaa asserts an anonymous function, \ud835\udf06 of \ud835\udc65 returning expression, \ud835\udc52 is of type \ud835\udf0f\u2192\ud835\udf0f'. this means that if we know \ud835\udc65 is of type \ud835\udf0f and thus an expression \ud835\udc52 is of type \ud835\udf0f', then a function of \ud835\udc65 returning expression \ud835\udc52 is of type \ud835\udf0f\u2192\ud835\udf0f'. let variable declaration given \ud835\udeaa asserts \ud835\udc52\u2080, of type \ud835\udf0e, and \ud835\udeaa and \ud835\udc65, of type \ud835\udf0e, asserts \ud835\udc52\u2081 of type \ud835\udf0f conclude \ud835\udeaa asserts code_removed \ud835\udc65=\ud835\udc52\u2080 code_removed \ud835\udc52\u2081 of type \ud835\udf0f this means if we have an expression \ud835\udc52\u2080 that is a \ud835\udf0e (being a variable or a function), and some name, \ud835\udc65, also a \ud835\udf0e, and an expression \ud835\udc52\u2081 of type \ud835\udf0f, then we can substitute \ud835\udc52\u2080 for \ud835\udc65 wherever it appears inside of \ud835\udc52\u2081. instantiation given \ud835\udeaa asserts \ud835\udc52 of type \ud835\udf0e' and \ud835\udf0e' is a subtype of \ud835\udf0e conclude \ud835\udeaa asserts \ud835\udc52 is of type \ud835\udf0e this is saying that if an instance is of a type that is a subtype of another type, it is also an instance of that super-type. this allows us to use type instantiation in the more general sense that an expression can return a more specific type. generalization given \ud835\udeaa asserts \ud835\udc52 is a \ud835\udf0e and \ud835\udefc is not an element of the free variables of \ud835\udeaa, conclude \ud835\udeaa asserts \ud835\udc52, type for all argument expressions \ud835\udefc returning a \ud835\udf0e expression this means we can generalize a program to accept all types for arguments not already bound in the containing scope (variables that are not non-local). these bound variables are substitutable. conclusion these rules combined allow us to prove the most general type of an asserted program, without requiring type annotations, allowing for various types to be accepted correctly as input (parametric polymorphism).", "if you are looking for a good explanation of the algorithm, the best that i've found so far is in chapter 30 of shriram krishnamurthi's programming languages: application and interpretation (cc licensed!).", "code_removed should always do the same thing as code_removed. i've removed the example from the answer.", "oh, in february we also had 6 people attend a \"snap summit\" in new york city. one even flew in from out of state on very short notice for the sole purpose of hacking on snap.", "my style may be cramped by my phone, but here goes. code_removed cannot be a functor. if it were, we'd have code_removed and the moon would be made of green cheese. meanwhile code_removed is a functor code_removed but cannot be applicative, or we'd have code_removed and green would be made of moon cheese (which can actually happen, but only later in the evening). (extra note: code_removed, as in code_removed is an empty datatype. if you try to use code_removed to prove it's a monoid, i'll use code_removed to prove that it isn't.) joyously, code_removed is applicative in many ways, e.g., as dijkstra would have it, code_removed but it cannot be a monad. to see why not, observe that return must be constantly code_removed or code_removed, and hence that code_removed cannot possibly hold. oh yeah, i nearly forgot code_removed is a monad. roll your own. plane to catch...", "@td123 i've updated the code to support unsorted lists.", "i agree. that's a damned nice answer.", "code_removed isn't an operator, it's a keyword, like code_removed or code_removed, so i think you could only alter the precedence using parentheses. see more here:", "the \"error\" function is for when a function receives invalid input, or when something internal happens that is supposed to never happen (i.e., a bug). in short, calling \"error\" represents a bug - either in the caller or callee. the \"undefined\" constant is more for values which aren't supposed to be used - generally because they're going to be replaced with something else, or because they're phantom values used to get a specific type. (it's actually implemented as a call to \"error\".) so why do we have code_removed with all its fanciness then? basically, \"because i/o operations can throw exceptions\". you could be happily talking to an ftp server over a tcp socket, and suddenly the connection breaks. the result? your program throws an exception. or you could run out of ram, or the disk might fill up, or whatever. notice that almost all of these things are not your fault. if you can anticipate a specific thing going wrong, you should use things like code_removed and code_removed to handle it in a pure way. (e.g., if you're going to invert a matrix, well, the matrix could be non-invertible, so you'd better return a code_removed as the result.) for things that you can't reasonably anticipate (e.g., some other program just deleted the file you're trying to work on), exceptions are the way. note that code_removed contains lots of stuff for handling exceptions as well as just defining lots of different types. i don't care if the code i called did something which is incorrect and therefore a bug; i'd still like to be able to tell the client i was just talking to that the connection is about to be closed, log a description to a log file somewhere, and do other cleanup stuff, rather than just have my program suddenly, you know, stop.", "i'm trying to understand monads as well. it's my version: monads are about making abstractions about repetitive things. firstly, monad itself is a typed interface (like an abstract generic class), that has two functions: bind and return that have defined signatures. and then, we can create concrete monads based on that abstract monad, of course with specific implementations of bind and return. additionally, bind and return must fulfill a few invariants in order to make it possible to compose/chain concrete monads. why create the monad concept while we have interfaces, types, classes and other tools to create abstractions? because monads give more: they enforce rethinking problems in a way that enables to compose data without any boilerplate.", "wasn't there a recent post on planet.haskell.org that proved, that arrows are nothing more than applicative functors?", "code_removed this can be useful to represent combinations of two values, where the combination is defined if either input is. algebraically, the type code_removed represents (a + b + ab), which doesn't factor easily into sums and products \u2014 a type like code_removed is unclear and awkward to use.", "wow, order of magnitude difference. excellent suggestion.", "@leftaroundabout, it's just that mathematicians always have to clean up the mess the physicists make. but we make our own mess sometimes too:-)", "can haskell provide some of the benefits of node.js, namely a clean solution to avoid blocking i/o without having recourse to multi-thread programming? yes, in fact events and threads are unified in haskell. you can program in explicit lightweight threads (e.g. millions of threads on a single laptop). or; you can program in an async event-driven style, based on scalable event notification. threads are actually implemented in terms of events, and run across multiple cores, with seamless thread migration, with documented performance, and applications. e.g. for massively concurrent job orchestration concurrent collections scaling on 32 or 48 cores tool support for profiling and debugging multi-threaded/multi-event programs. high performance event-driven web servers. interesting users: such as high-frequency trading. concurrent collections nbody on 32 cores in haskell you have both events and threads, and as it is all events under the hood. read the paper describing the implementation.", "some languages have a pseudo constant variable such as current_timestamp. it's a constant that's different every second.", "a maintainer of yesod suggesting giving a competing framework a try. what a great community we have.", "great. this and joseph's answer are two great examples of when fix seems to helpful.", "@papuccino1 - what benefit do the extra words in your title bring to the question? also, i think you're misunderstanding the use of the term \"functional\" in this context, but it's hard to tell.", "so looking forward to that.", "@ehird i meant to say necessary, i think my spell checker flipped the meaning.", "i couldn't find anything that does this on hackage. your code looks pretty good to me. some comments: code_removed this does not take into account that a file with the destination name might exist. code_removed you might want to throw an exception or return a status instead of printing directly from this function. code_removed since you're not using code_removed for anything, you can change this to code_removed", "@sibi links updated", "code_removed source: haskell programming from first principles, by chris allen and julie moronuki", "i completely agree with @breton. you gave good examples of what kinds of code uses monads but you failed, imo, to explain what a monad is and how it works, which is what's important.", "can maybe's type be code_removed? since code_removed is still a type constructor, does that mean it's impossible to write in the data-context, code_removed? because that would make the data ambiguous? and when you say \"where a type is expected\", that means in stuff like type signatures, declarations, data/newtype/type.. etc. but not in the actual \"code\", such as variable assignment, function application.. etc.", "was this intended as a comment on this answer? because it's not clear, and this isn't an answer on its own.", "i see... but how would i know that i made such a mistake? i edited the question to show the error - can you explain it?", "thank you so much!", "@dan you can get away completely free with smaller changes (like just adding a field) when you use records. some may want to make records a habit (i'm one of them ^^\").", "i disagree with the vote to move; i am asking this question in the same spirit that i asked what's so bad about lazy i/o? and i expect to see answers of the same fashion. i am open to rewording the question if that would help.", "i'm facing a related situation right now designing a merge api for code_removed. the \"open\" approach is preferable in some ways. for one thing, i can implement it without gadts and therefore maintain compatibility with report haskell. for another, i don't need huge case analyses everywhere. but it's unpleasant in some other ways; in particular, it's much harder for me to take advantage of what i know about the behavior of values constructed in particular manners to optimize things.", "i would be failing in my duty as his supervisor if i failed to plug adam gundry's inch preprocessor, which manages integer constraints for haskell. smart constructors and abstraction barriers are all very well, but they push too much testing to run time and don't allow for the possibility that you might actually know what you're doing in a way that checks out statically, with no need for code_removed padding. (a pedant writes. the author of another answer appears to suggest that 0 is positive, which some might consider contentious. of course, the truth is that we have uses for a variety of lower bounds, 0 and 1 both occurring often. we also have some use for upper bounds.) in the tradition of xi's dml, adam's preprocessor adds an extra layer of precision on top of what haskell natively offers but the resulting code erases to haskell as is. it would be great if what he's done could be better integrated with ghc, in coordination with the work on type level natural numbers that iavor diatchki has been doing. we're keen to figure out what's possible. to return to the general point, haskell is currently not sufficiently dependently typed to allow the construction of subtypes by comprehension (e.g., elements of integer greater than 0), but you can often refactor the types to a more indexed version which admits static constraint. currently, the singleton type construction is the cleanest of the available unpleasant ways to achieve this. you'd need a kind of \"static\" integers, then inhabitants of kind code_removed capture properties of particular integers such as \"having a dynamic representation\" (that's the singleton construction, giving each static thing a unique dynamic counterpart) but also more specific things like \"being positive\". inch represents an imagining of what it would be like if you didn't need to bother with the singleton construction in order to work with some reasonably well behaved subsets of the integers. dependently typed programming is often possible in haskell, but is currently more complicated than necessary. the appropriate sentiment toward this situation is embarrassment, and i for one feel it most keenly.", "nishant shukla's lectures is a pretty good starting point to the absolute beginner. they offer a nice introduction to haskell.", "i'm trying to add an instance declaration in haskell for a new data type i've created unsuccessfully. here what i've tried so far: code_removed seems the last line is wrong but i'm not sure how to achieve what i want. basically is to be able to call from the interpreter a prediction variable and get it visualized without having to call the showprediction. right now this works: code_removed and shows: code_removed as expected, but i would like this to work (from the interpreter): code_removed any ideas?", "how can i access a list by index in haskell, analog to this c code? code_removed", "it appears to be a problem involving return type polymorphic recursion.", "@leftaroundabout i'm curious to understand how code_removed relates to code_removed.", "this might apply for any type class, but lets do it for functors as i know them better. i wan't to construct this list. code_removed and then code_removed to get code_removed i know they are all functors that contain ints so it might be possible. how can i do this? edit this is turning out to be messier than it would seem. in java or c# you'd declare the code_removed interface and then just write code_removed assuming code_removed, code_removed and code_removed implement the code_removed. naturally code_removed and code_removed extend code_removed and code_removed and code_removed extend code_removed. not satisfied with this problem being easier to resolve on these languages!!! there should cleaner way in haskell:(", "@sergio tapio: i don't think so. your question asks \"where i will be able to use haskell\", i asked \"what kind of useful knowledge i'll get from it\". i don't care if language popular or not, but if it teaches some kind of concept i'll be able to (possibly) reapply in another language, it may be worth my time.", "@barendventer no, it can. try to replace 'u' in (*) with random type variable, your code will still compile. hint: type variables aren't scoped in this case.", "code_removed", "because there is syntactic sugar associated with them.", "i'd say that in most languages you're not even be able to declare such a pair:-)", "the answers to my question about criterion may contain some helpful usage examples stackoverflow.com/questions/6637968/\u2026.", "i want a templatehaskell function code_removed that returns a list of the code_removed's of all the variables in scope. templatehaskell obviously has this information available in order to implement functions like code_removed and code_removed. does the function i want exist somewhere and i just overlooked it? or can it be easily built somehow?", "this is awesome", "looking at the core from -ddump-simpl, there's a new wrapper $wsrcspanx when the strictness is introduced, and i'm not sure if it's being universally inlined.", "no, but you can use better functions. i'm not talking about code_removed, which would make things certainly a lot faster, but about code_removed. we have three candidates that already do what code_removed does: code_removed all versions take around 8 seconds, compared to the 40 seconds your versions take. joachim's version also takes 8 seconds, by the way. note that the code_removed version takes more memory on my system. while there is an unroll plugin for ghc, it hasn't been updated in the last five years (it uses custom annotations). no unroll at all? however, before we despair, how well does ghc actually try to inline everything? let's use code_removed and code_removed: code_removed code_removed code_removed we can stop right there. code_removed is the code_removed defined above. even with code_removed ghc does not unroll the loop. it's disturbing since code_removed is a constant. templates to the rescue but alas, it's not all for naught. if c++ programmers are able to do the following for compile time constants, so should we, right? code_removed and sure enough, we can, with templatehaskell*: code_removed what does code_removed do? it creates a new function where the first name code_removed is going to be applied to the second name code_removed for a total of code_removed times. code_removed now needs to be a compile-time constant, which suits us, since loop-unrolling is only possible with compile-time constants: code_removed does it work? and is it fast? how fast compared to code_removed? let's try another code_removed for that: code_removed code_removed code_removed it yields the correct result. how fast is it? let's use another code_removed again: code_removed code_removed well, compare that to the 8s. so for a tl;dr: if you have compile-time constants, and you want to create and/or modify your code based on that constants, consider template haskell. * please note that this is my first template haskell code i've ever written. use with care. don't use too large code_removed, or you might end up with a messed up function.", "@chuck - it appears to have been written in c. fourmilab.ch/autofile/www/subsection2_38_3_1.html", "to expand a bit on carl's answer, if there was such a thing as code_removed, but for applicatives: code_removed then you would automatically have a monad: code_removed", "sigh... i'm not making an attack on haskell... i was making a joke. so, i don't really get the bit about being \"ad hominem\". yes, the calculus was \"designed\". that's why, for example, calculus students are taught the leibniz notation, rather than the icky stuff netwton used. better design. good names help understanding a lot. if i called abelian groups \"distended wrinkle pods\", you may have trouble understanding me. you might be saying \"but that name is nonsense\", no one would ever call them that. to people who have never heard of category theory \"monad\" sounds like nonsense.", "the question is pretty ridiculous because 1) haskell has already solved this issue in a much better way and 2) in roughly the same way erlang has. here is the benchmark against node: give haskell 4 cores and it can do 100k (simple) requests per second in a single application. node can't do as many, and can't scale a single application across cores. and you don't have to do anything to reap this because the haskell runtime is non-blocking. the only other (relatively common) language that has non-blocking io built into the runtime is erlang.", "you can make legitimately make anything from a \"value\" in void, for example, a proof of a false equation between types; of course, the only problem is that your data become mined with bottoms, so as long as crashing out or looping with bottom are not considered \"going wrong\", nothing will go wrong", "yea pretty much. but i did some reading about kinds, and so now my perspective is that the word \"kind\" is like asking what the type of type is it? whereas \"type\" is like asking what the type of this value is it? which is why i can't type code_removed but i can do code_removed. i wonder if there is some language joins the concepts of types and values together, so that all constructors are just at some level of abstraction.", "@r.martinhofernandes: though the last two codepoints in each plane are permanently unassigned, so i guess the greatest possible assignable codepoint would be u+10fffd. (not sure if that makes a difference...)", "hey, ertes, you seem to have another account, both of which are unregistered. if you register your account, you can merge them and then have a single account for all your answers (which are really good, by the way!).", "@benmachine i did check (with the rest of the code given by op), and it does actually work (i checked it on a small test file with 5 lines). it also works using code_removed in place of (code_removed. however, now that you mention it, it does seem odd: why didn't it just grab the first line and quit after that?", "oh, weird. for some reason i thought it was lisp. thanks for the correction.", "sorry for being a pain, but the type returning from round code_removed getposixtime comes up as t:: io integer", "@dietrich epp: let's say that we've chosen, as curry said, not to run away from paradoxes. code_removed is a \"value\" in some senses, but obviously we can't observe it directly. however, we can observe aspects of a code_removed in other ways, such as by catching exceptions in code_removed, or personally observing nontermination vs. code_removed. so, as we leave the \"close your eyes and pretend this is agda\" realm that calls code_removed an empty type, can you show that your proposed code_removed instance will obey the laws as applied to what sort of code_removed it produces?", "code_removed should do the trick as well.", "@danburton how about code_removed? here too, manually?:)", "changed ticks to backticks, my mistake. and whether it is considered a hidden feature or not, it depends on how much knowledge you have on the language. sorry if you didnt like it.", "i think this might be too broad a question for so.", "@cslv note that this question has been closed twice now as \"too broad\", as in you would need a book or several blog posts to answer this question (on top of pointing out the op's faulty understanding). i fail to see how this question can be considered anything other than too broad.", "@evi1m4chine i mean anything you can do with an oo interface can be done with a typeclass, plus a hell of a lot more. so you kind of can just use them as a replacement for java interfaces 99% of the time and be very happy with the huge increase in power.", "@dietrichepp i don't follow what you are saying. can you point to a specific example code for the multidimensional array? also i don't see how it helps to look at code_removed as tensor product. i'd rather agree that the monoidal operation code_removed is similar to a tensor product. but i still don't see how this helps to verify that tensor arrays have no monad instance.", "can be done using fold: code_removed", "@danielwagner isn't converting every element to a list and then concatenating lists kinda expensive?", "also, i would argue that monads are essentially imperative in nature. if the functor represents some structure with values embedded in it, a monad instance means you can build and flatten new layers based on those values. so whatever meaning you assign to a single layer of the functor, a monad means you can create an unbounded number of layers with a strict notion of causality going from one to the next. specific instances may not have intrinsically imperative structure, but code_removed in general really does.", "@dfeuer oh. to put it in code, code_removed. kleisli categories are functions where the categorical return type (code_removed in this case) is the argument to a type constructor code_removed. iff code_removed forms a category, code_removed is a monad.", "(see also the answers at what is a monad?) a good motivation to monads is sigfpe (dan piponi)'s you could have invented monads! (and maybe you already have). there are a lot of other monad tutorials, many of which misguidedly try to explain monads in \"simple terms\" using various analogies: this is the monad tutorial fallacy; avoid them. as dr maciver says in tell us why your language sucks: so, things i hate about haskell: let\u2019s start with the obvious. monad tutorials. no, not monads. specifically the tutorials. they\u2019re endless, overblown and dear god are they tedious. further, i\u2019ve never seen any convincing evidence that they actually help. read the class definition, write some code, get over the scary name. you say you understand the maybe monad? good, you're on your way. just start using other monads and sooner or later you'll understand what monads are in general. [if you are mathematically oriented, you might want to ignore the dozens of tutorials and learn the definition, or follow lectures in category theory:) the main part of the definition is that a monad m involves a \"type constructor\" that defines for each existing type \"t\" a new type \"m t\", and some ways for going back and forth between \"regular\" types and \"m\" types.] also, surprisingly enough, one of the best introductions to monads is actually one of the early academic papers introducing monads, philip wadler's monads for functional programming. it actually has practical, non-trivial motivating examples, unlike many of the artificial tutorials out there.", "so, lifting = applicative functor?", "any pointers on how to solve efficiently the following function in haskell, for large numbers code_removed code_removed i've seen examples of memoization in haskell to solve fibonacci numbers, which involved computing (lazily) all the fibonacci numbers up to the required n. but in this case, for a given n, we only need to compute very few intermediate results. thanks", "i have a very simple question: given a function accepting a char and returning a string code_removed how can one convert the char into a string? i'm confused over the two types.", "in the code_removed newtype, i can't figure out what the code_removed constraint is doing. could you explain?", "ghci now has a multiline-input mode, enabled with:set +m. for example, code_removed", "would it be possible to rearrange things to avoid the runtime code_removed? maybe some type indexing trick?", "in addition to what daniel wagner listed you may want to take a look at a similar question is there a haskell compiler or preprocessor that uses strict evaluation?. answers include the ddc compiler which attempts to make an strict version of haskell and only lazy explicitly ghc plugin described in monad.reader 12 \"using nfdata and rnf everywhere\" - solrize and more the predominate suggestion is to use profiling tools and learn how to optimize haskell as it is however, since most would consider it a different language with non-strict evaluation turned off.", "guys, monads are from the math world. if you want to know what a monad is, you have to talk to a mathematician. just because it is in some programming languages it doesn't mean programmers are suppose to explain what it is. for example, programming languages can sum numbers, but if you want to have an explanation about what summing is you have to talk to a mathematician. i hope it is clear now. my fellow programmers, stop trying to explain monads.", "code_removed", "i spoke to the author a while back, and he confirmed that the online version of the book is out of date. there's a more up-to-date version on pdf: [here]", "@crisp i believe the last link is what is being referred to. it goes to a page on the ghc wiki about the demand analyzer in ghc.", "\"functional guis\" link broken:( cached: webcache.googleusercontent.com/search?q=cache:", "@ernesto there may be a (very minor) performance difference between the two but you'd be firmly in the realm of microoptimisations. the impact on flexibility is much more important.", "@danielfischer thanks for the suggestions, i updated the example. (yes, it was generated by a command line tool for abstraction elimination.)", "this isn't the last \"weird haskell symbol\" you will come across:)", "what is the difference when i write this? code_removed", "snap has pretty good momentum. first of all, it was the most downloaded web framework on hackage last year even though the project didn't launch publicly until may. second, since the 0.3 release in december, we've seen a big increase in activity. libraries for sessions, auth, mongodb, the xmlhtml library, and more are all being worked on by people who are for the most part new contributors in 2011. you can also usually find 30 or more people in the #snapframework irc channel. it is definitely an active project.", "to add to hammar's excellent direct answer: humble functions like code_removed and code_removed are really useful as a higher order function for the same reason that they are fundamental in the ski combinator calculus. not that i think haskell's prelude functions were modeled consciously after that formal system or anything. it's just that creating rich abstractions in haskell is very easy, so you often see these types of theoretical things emerge as practically useful. shameless plug, but i blogged about how the applicative instance for code_removed are actually the code_removed and code_removed combinators here, if that's the kind of thing you're into.", "@cubic, thank you so much, at first i didn't grok what you meant but ghci's type system helped me! for your edification, my example; ---code-- let try:: [integer -> b] -> [b]; try = map ($3); let adda:: integer -> integer; adda x = 7 + x; let suba:: integer -> integer; suba x = x - 7; -- now doing it: --; try [adda, suba] ; -- result = [10,-4] ///i apologize we can't format comments as code", "@jrg there is some overlap, but it's not specifically because of type constructors but because of type variables, e.g. the code_removed in code_removed. code_removed is a placeholder for an arbitrary type. you can have the same in plain functions though, e.g. a function of type code_removed takes a tuple of two values (of types code_removed and code_removed) and yields the first value. it's a \"generic\" function in that it doesn't dictate the type of the tuple elements - it only specifies that the function yields a value of the same type as the first tuple element.", "there are cons to using haskell for certain projects, but there are no cons to learning haskell. it takes time, but it is worth it. you will be a better programmer.", "does code_removed vs code_removed make a difference for erasing the proxy? edward kmett says: \"no, ghc isn't very smart about free theoremish thinking.\"", "could you say what you have in mind for an ideal treatment of programming with effects?", "another thing that is unclear to me is the meaning of \"pure\": if it means there are no sideeffects, well, they are there.", "i will again run with the theme of the other answers here and suggest that you parse as though you are just creating the naive representation with named variables. if you want to avoid the intermediate representation, you can kind of inline it into the parser without making it any harder to understand: code_removed the idea is that instead of using the constructors of your intermediate representation in your parser, you use these functions directly. they have the same types that the constructors would have, so it's really just a drop-in replacement. it's also a bit shorter, since now we don't have to separately write out the adt and interpreter.", "i think pronouncing code_removed as \"after\" is more sensible. composition can be denoted in two directions, and calling it \"after\" immediately explains how it works, too.", "not that hidden", "in haskell, a proxy is a type witness value that makes it easy to pass some types around code_removed an example use is here in json-schema: code_removed so you could do code_removed to obtain what the json representation for an int-char-tuple would be (probably an array). why do people use proxies? it seems to me that the same could be accomplished by code_removed similar to how the code_removed typeclass works. i first thought it might be easier to get the schema of some given value when using proxies, but that doesn't seem to be true: code_removed also, one might worry about whether the code_removed values are actually eradicated at runtime, which is an optimisation problem that doesn't exists when using the code_removed approach. if the code_removed approach as taken by code_removed achieves the same result with shorter code and less worries about optimisation, why do people use proxies? what are the benefits of proxies? edit: some answers and commenters rightfully pointed out that the code_removed approach taints the code_removed type with a \"useless\" type parameter - at least from the perspective of the plain data structure itself, which doesn't ever use the code_removed (see here). the suggestion is to use the phantom type code_removed instead, which allows to separate the two concerns (code_removed combines the non-parametric schema type with a type variable code_removed), which is strictly better than the code_removed approach. so my the question should better be what are the benefits of proxies vs. the tagged approach?", "do \"simple things\" count as hidden features of haskell? is this question a discussion list of every haskell feature?", "you should have a look at graph reduction using combinators (ski). it's beautiful and simple and illustrates how lazy evaluation works.", "this line is so beautiful....", "in the list monad, i like to think of code_removed as representing a set of possible choices: 1 or 2. when we do operations on such a set, we produce a set of possible results. what is \u201c1 or 2\u201d plus 4? naturally, \u201c5 or 6\u201d. in haskell, we can phrase that question as code_removed and get the expected answer code_removed. the list monad represents nondeterminism in that it lets us talk about the whole tree of possible choices, without actually committing to any of those choices. so what is \u201c1 or 2\u201d plus \u201c4, 5, or 6\u201d? well, that could be: 1 + 4 = 5 or + 5 = 6 or + 6 = 7 or 2 + 4 = 6 or + 5 = 7 or + 6 = 8 we can encode the question in haskell with the list monad (as exhaustive calculation of all the solutions, in order): code_removed or with the list applicative (doing the same): code_removed and the answer is of course code_removed. if it helps, you can also think of the list monad, or list comprehensions, as performing a sort of cartesian product. a different way of encoding this is to start an independent concurrent computation for each of the choices, at once, producing the final results without any inherent order.", "the file is being closed too early. from the documentation: the handle will be closed on exit from withfile this means the file will be closed as soon as the code_removed function returns. because code_removed and friends are lazy, it won't try to read the file until it is forced with code_removed, but by then, code_removed would have closed the file already. to solve the problem, pass the whole thing to code_removed: code_removed this works because by the time code_removed gets around to closing the file, you would have already printed it.", "@augustss i do not understand yet why for code_removed you need the proxy. could you elaborate a bit?", "note: the solution is up for code review.", "it's possible to use the code_removed library in order to do this, see code_removed: code_removed shelly first tries to use native code_removed if available. if not, it falls back to a native haskell code_removed implementation. for further details on type semantics of code_removed, see this post written by me to described how to use code_removed with code_removed and or code_removed.", "i'm also inclined to say that if a type class can be represented straightforwardly by record of instance members, that representation is almost always better than messing around with annoying existentials. i usually cite luqui's blog here, but... it looks like @heinrich already took care of that, heh.", "+1 for first paragraph, exactly what i thought when i read the question. for the sake of learning new things, i would suggest a modern imperative language, like python - especially since it's not what the op's used to (dynamic typing, iterators everywhere, etc). it also has very cool advanced concepts like metaclasses or generators (which are strikingly similar to lazy lists)/generator expressions (which serve as a generalization of list comprehensions + generators). also, dict and set comprehensions rule.", "@ziggystar - the \"world object\" doesn't actually include anything - it is simply a proxy for the changing state of the world outside of the program. its only purpose is to explicitly mark mutable state in a way that the type system can identify it.", "i'm not sure whether or not haskell supports this but mathematically you can define a monad either in terms of >>= and return or join and ap. >>= and return are what make monads practically useful but join and ap give a more intuitive understanding of what a monad is.", "hmm, the example on that page you referenced seems to talk about the use of! when invoking a function. but that seems different than putting it in a type declaration. what am i missing?", "my answer is fundamentally the same as erikr's: the type that best embodies your requirements is code_removed. but i'll go a bit more into the logic that i believe justifies this answer. the key is in this quote from the question: [...] things which have one property in common, namely, they could be turned into string. let's call this type code_removed. but now the key observation is this: code_removed is isomorphic to code_removed! that is, if your statement above is the whole specification of the code_removed type, then there is a pair functions with these signatures: code_removed ...such that the two functions are inverses. when two types are isomorphic, any program that uses either of the types can be rewritten in terms of the other without any change to its semantics. so code_removed doesn't let you do anything that code_removed doesn't let you do already! in more concrete terms, the point is that this refactoring is guaranteed to work no matter what: at every point in your program where you turn an object into a code_removed and stick that into a code_removed, turn the object into a code_removed and stick that into a code_removed. at every point in your program that you consume a code_removed by applying code_removed to it, you can now eliminate the call to code_removed. note that this argument generalizes to types more complex than code_removed, with many \"methods\". so for example, the type of \"things that you can turn into either a code_removed or an code_removed\" is isomorphic to code_removed. the type of \"things that you can either turn into a code_removed or combine them with a code_removed to produce a code_removed\" is isomorphic to code_removed. and so on. basically, this logic leads to the \"record of methods\" encoding that other answers have brought up. i think the lesson to draw from this is the following: you need a specification richer than just \"can be turned into a string\" in order to justify using any of the mechanisms you brought up. so for example, if we add the requirement that code_removed values can be downcast to the original type, an existential type now perhaps becomes justifiable: code_removed this code_removed type is not isomorphic to code_removed, because the code_removed constraint allows us to implement the code_removed function that allows us to distinguish between different code_removeds that produce the same string. a richer version of this idea can be seen in this \"shape example\" gist.", "@dan_waterworth exactly, see meteor or derby.js", "i spoke to the author a while back, and he confirmed that the online version of the book is out of date. there's a more up-to-date version on pdf: [here]", "i would like this open", "@camccann i think making it explicit is better, since some players may need code_removed why others don't. (easier for debugging and testing ais)", "why do you assume that code_removed doesn't avoid the multiple traversal of code_removed when code_removed is used multiple times, but do assume that code_removed does avoid the multiple traversal of its definition when code_removed is used multiple times?", "i'm new with haskell and have trouble with its package. i want to import system.random but could not find module `system.random' then i tried to import system but could not find module `system'. it is a member of the hidden package `haskell98-2.0.0.0'. i tried to search this problem, but those solutions still don't work. as this said, i tried to install cabal on my mac os x using macport, but error: the following dependencies were not installed: ghc error: status 1 encountered during processing. i have installed haskell platform and can use ghci in command-line. ghci, version 7.2.1 then i tried to use code_removed as this one says. but this time, i can't even run ghci. top level: ambiguous interface for `prelude': it was found in multiple packages: base haskell98-2.0.0.0 so, what can i do without using cabal?", "perhaps some nice notation would be easier on the eyes: code_removed if you need to use the parameters more than once, i suggest going with @pat's method. edit 6 years later with code_removed you can put the defaults on the left. code_removed", "if you strip the binary, does it remove the constructor name from it? i would expect it's only present as a debugging aid.", "then the actual code_removedstatic function (not the method) is just code_removed", "thanks. \"real world haskell\" (at least the version i have) doesn't have the code_removed in its examples", "@semicolon memorization. in this case i think that haskell memorized all primes at runtime so it doesn't need to recompute them each iteration.", "@max: yup - i was just going for clarity. ymmv:)", "@dan: native executables can't run on different platforms (at least not without extra emulation effort on all but one platforms).", "the horizontal bar means that \"[above] implies [below]\". if there are multiple expressions in [above], then consider them anded together; all of the [above] must be true in order to guarantee the [below]. code_removed means has type code_removed means is in. (likewise code_removed means \"is not in\".) code_removed is usually used to refer to an environment or context; in this case it can be thought of as a set of type annotations, pairing an identifier with its type. therefore code_removed means that the environment code_removed includes the fact that code_removed has type code_removed. code_removed can be read as proves or determines. code_removed means that the environment code_removed determines that code_removed has type code_removed. code_removed is a way of including specific additional assumptions into an environment code_removed. therefore, code_removed means that environment code_removed, with the additional, overriding assumption that code_removed has type code_removed, proves that code_removed has type code_removed.", "you seem to be the only one who finally addressed my main problem with understanding monads. nobody ever talks about how can the value be extracted. is it implementation dependant?", "this is quite surprising to me, though i have yet to try it. since the original code_removed was tail recursive i would have thought the compiler could spot the extra parameters not being changed and optimize the tail recursion only for the changing parameters (haskell being a pure language after all, this should be easy). anyone thinks the compiler could do that or should i go back to read more theory papers?", "haskell 2010 is entirely backwards compatible with real implementations of haskell 98, i believe; the breaking change in syntax was something that every compiler already implemented the way haskell 2010 mandates.", "how about code_removed (note code_removed to match the question's behaviour)?", "btw, for \"what exactly is the name go supposed to imply?\" i would say it hints at code_removed, and at handing over control to a helper function.", "\"i have recently learned about data.function.fix, and now it seems to me that i want to apply it everywhere.\" this makes you a boy scout haskell programmer then - willamette.edu/~fruehr/haskell/evolution.html#boyscout", "with the new polykinded code_removed you no longer need code_removed.", "this differentiation/one hole context stuff is pretty cool. let's see if i have this straight. a pair, with algebraic representation code_removed, has derivative code_removed, so code_removed is the one-hole context of pair. that's pretty cool. we could 'integrate' code_removed to get a pair too. but if we try to 'integrate' code_removed (with type code_removed) then we need to have code_removed which is nonsensical (what's half a type?) does this mean that code_removed isn't the one-hole context of any other type?", "haskell is my favourite programming language, by far, but nevertheless uncyclopedia.wikia.com/wiki/haskell made me laugh so much!", "can anybody completely explain the forall keyword in clear, plain english? no. (well, maybe don stewart can.) here are the barriers to a simple, clear explanation or code_removed: it's a quantifier. you have a to have at least a little logic (predicate calculus) to have seen a universal or existential quantifier. if you've never seen predicate calculus or are not comfortable with quantifiers (and i have seen students during phd qualifying exams who are not comfortable), then for you, there's no easy explanation of code_removed. it's a type quantifier. if you haven't seen system f and gotten some practice writing polymorphic types, you're going to find code_removed confusing. experience with haskell or ml is not enough, because normally these languages omit the code_removed from polymorphic types. (in my mind, this is a language-design mistake.) in haskell in particular, code_removed is used in ways that i find confusing. (i'm not a type theorist, but my work brings me in contact with a lot of type theory, and i'm quite comfortable with it.) for me, the main source of confusion is that code_removed is used to encode a type that i myself would prefer to write with code_removed. it's justified by a tricky bit of type isomorphism involving quantifiers and arrows, and every time i want to understand it, i have to look things up and work out the isomorphism myself. if you are not comfortable with the idea of type isomorphism, or if you don't have any practice thinking about type isomorphisms, this use of code_removed is going to stymie you. while the general concept of code_removed is always the same (binding to introduce a type variable), the details of different uses can vary significantly. informal english is not a very good tool for explaining the variations. to really understand what's going on, you need some mathematics. in this case the relevant mathematics can be found in benjamin pierce's introductory text types and programming languages, which is a very good book. as for your particular examples, code_removed should make your head hurt. higher-rank types (forall to the left of an arrow) are rarely found in the wild. i encourage you to read the paper that introduced code_removed: \"lazy functional state threads\". this is a really good paper, and it will give you a much better intuition for the type of code_removed in particular and for higher-rank types in general. the explanation take several pages, it's very well done, and i'm not going to try to condense it here. consider code_removed if i call code_removed, i can simply pick any type code_removed that i like, and i can pass it a function from type code_removed to type code_removed. for example, i can pass the function code_removed or the function code_removed. you can think of the code_removed as saying \"i get to pick the type now\". (the technical word for picking the type is instantiating.) the restrictions on calling code_removed are much more stringent: the argument to code_removed must be a polymorphic function. with that type, the only functions i can pass to code_removed are code_removed or a function that always diverges or errors, like code_removed. the reason is that with code_removed, the code_removed is to the left of the arrow, so as the caller of code_removed i don't get to pick what code_removed is\u2014rather it's the implementation of code_removed that gets to pick what code_removed is. because code_removed is to the left of the arrow, rather than above the arrow as in code_removed, the instantiation takes place in the body of the function rather than at the call site. summary: a complete explanation of the code_removed keyword requires math and can be understood only by someone who has studied the math. even partial explanations are hard to understand without math. but maybe my partial, non-math explanations help a little. go read launchbury and peyton jones on code_removed! addendum: jargon \"above\", \"below\", \"to the left of\". these have nothing to do with the textual ways types are written and everything to do with abstract-syntax trees. in the abstract syntax, a code_removed takes the name of a type variable, and then there is a full type \"below\" the forall. an arrow takes two types (argument and result type) and forms a new type (the function type). the argument type is \"to the left of\" the arrow; it is the arrow's left child in the abstract-syntax tree. examples: in code_removed, the forall is above the arrow; what's to the left of the arrow is code_removed. in code_removed the type in parentheses would be called \"a forall to the left of an arrow\". (i'm using types like this in an optimizer i'm working on.)", "@peterwortmann, nice! though for future-proofing it against unaware maintainers, that solution is a bit more obscure.", "@hynek: this qi 2 language at first glance seems very interesting and more flexible than either coq or adga. it seems though the author has decided to call it quits. is there any movement to continue working on this language? i wouldnt want to learn something that is already half dead.", "this already helps a lot; this provides a local-non-ssl-to-remote-ssl proxy corresponding to code_removed client-mode, could you also provide an example how to listen to a local ssl socket (e.g. to provide a local-ssl-to-remote-non-ssl proxy)?", "\"learning haskell will ruin all other languages for you.\" so true. before i wrote in haskell, i was thinking for every project i started \"ok, what language will that be in?\". now i'm not even considering anything else than haskell (except possibly agda or idris). to be fair, i don't know whether that's so much of a contra. a lot does indeed work better in haskell. the main problem of only working in haskell is that there are good libraries and frameworks for specific tasks that one can't use without effort, because they are in a different language (say, node.js etc.)", "that's good advice.", "undefined behavior probably isn't the most apt term. it's hard to understand just based off one program. the problem is deciability and ghci not being able to prove the types in your program. there's a long discussion that might interest you on just this subject. haskell.org/pipermail/haskell-cafe/2008-april/041397.html", "@lifuhuang yep, you've pointed out the exact difficulty! i suspect there are no shortcuts and a satisfying explanation requires introducing the categorical notion of a monoid and showing how that specializes to set and end respectively.", "it sort of has one in that you can write code_removed to get a map that sends code_removed to code_removed and code_removed to code_removed. i know that this isn't actually a literal, but it's pretty close. it is a constant applicative form, so the function call can be optimized away by the compiler.", "note: no, this isn't true. at some point there was a comment on this answer from dan piponi himself saying that the cause and effect here was exactly the opposite, that he wrote his article in response to james iry's quip. but it seems to have been removed, perhaps by some compulsive tidier. below is my original answer. it's quite possible that iry had read from monoids to monads, a post in which dan piponi (sigfpe) derives monads from monoids in haskell, with much discussion of category theory and explicit mention of \"the category of endofunctors on hask\". in any case, anyone who wonders what it means for a monad to be a monoid in the category of endofunctors might benefit from reading this derivation.", "@yellpika sadly, you're stuck with it if you use too many higher rank types.", "this is also a good solution, it should remind the reader of an explicit proof by induction on [n].", "its also for controlling your death ray with high accuracy! yellosoft.us/evilgenius", "ghc core is the system fc language into which all haskell is translated. the (approximate) grammar for core is given by: core is closely related to the simpler and better known system f. all transformations ghc does on the core level are type-preserving refactorings of this core representation, to improve performance. and, not so well known, you can write directly in core to program ghc. ghc core fits in the compiler pipeline (as it was in 2002, sans-llvm and cmm): the primary documents to learn about ghc core are: an external representation for the ghc core language, tolmach, 2001 ghc/compiler/coresyn, the ghc definition itself secrets of the glasgow haskell compiler inliner, peyton jones and marlow, 1999. core is described in section 2.3, including details on the occurrence analysis annotations. a transformation-based optimiser for haskell, peyton jones and santos, 1998. core is described in s3, including a discussion of polymorphism and operational readings of core. related material that can aid understanding: the ghc -fext-core output i spent a lot of time learning core by reading ghc source. some is described in my undergraduate thesis from 2002, from page 16. from using the ghc-core tool, to generate core in a format i find pleasing. core in turn is translated into stg code, which looks something like: the funny names in core are encoded in the \"z-encoding\": ghc core's types and kinds (from tolmach's paper): finally, ghc's primops appear regularly in ghc core output, when you have optimized your haskell down to the basic instructions ghc knows about. the primop set is given as a set of core functions in a pre-processed file.", "have a look at this answer about lists vs arrays: stackoverflow.com/questions/8196667/haskell-arrays-vs-lists vectors have mostly the same performance as arrays, but a larger api.", "as others have noted, code_removed is lazy. you can, however, add strictness if you so desire: code_removed though it is generally recommended that you perform all io related to the contents of the file inside of the code_removed block instead. that way, your program can actually take advantage of the lazy file read, keeping only as much as necessary in memory. if you are dealing with a very large file, then forcing the whole file to be read into memory is usually a bad idea. if you need more fine-grained control of resources, then you should look into using code_removed (which comes with the conduit package) or similar. [edit: use code_removed from code_removed (instead of code_removed) to make sure the whole value is forced. thanks for the tip, @benmachine]", "would it be possible to create something with template haskell that sort of gives you a map literal? i'm not that familiar with how haskell macros work so forgive me if that's a dumb question.", "floating point numbers are, strictly, speaking, not genuine monoids because they fail associativity, no?", "\"an external representation for the ghc core language\" is a document which can be found in the installation of ghc (code_removed) or on the internet.", "@konrad: they do the same thing in the sense that both use type system features to abstract side effects, but that's about it. note that it's very well to explain the io monad in terms of a world type, but the haskell standard doesn't actually define a world type and it's not actually possible to get a value of type world in haskell (while it's very possible and indeed necessary in clean). further haskell does not have uniqueness typing as a type system feature, so if it did give you access to a world, it could not ensure that you use it in a pure way the way clean does.", "very good point about code_removed being so light weight in haskell!", "these are less \"real worldy\", but i'd like to see helpful introductions (and possible real world applications?) to djinn template haskell arrows", "the first snippet is what we call closed. that means it is not extensible whereas the second snippet is: we can create as many code_removed objects we like, without being restricted to code_removed and code_removed. but you're right, those are pretty similar in the way we use it, except for pattern matching. you can pattern-match with the first snippet but not with the second. however, this is not a problem if you derive the second definition of code_removed from the code_removed typeclass to allow comparison to code_removed and code_removed.", "of course, for the single-constructor, single-item cases, code_removed is preferred over code_removed.", "i am trying and failing to grok the code_removed function from code_removed. i am unable to see its point. since i come from an imperative background, can someone please explain it to me in terms of an imperative loop? pseudo-code would be much appreciated. thanks.", "to precisely understand the meaning of polymorphism, i find it convenient to think about functional languages with explicit type arguments -- either theoretical ones, such as system f, or real-world ones such as agda, idris, coq, etc. in these languages, types are passed as function arguments as values normally are. if we have a polymorphic function code_removed this actually expects a type as a first argument, like this: code_removed note how the code_removed in the resulting type gets instantiated to the type argument. adding typeclass constraints, we have that code_removed can be seen as a function expecting: 1) a type argument code_removed, 2) a proof that the chosen type is a code_removed (e.g. a typeclass dictionary). when this is provided, a result of the chosen type code_removed will be returned. a more pedantic definition could be code_removed where code_removed is used as a type-level lambda, for the additional arguments described earlier. a call could then be as follows: code_removed which will return code_removed. now, what happens if we write the posted code? code_removed well, now code_removed and code_removed expect type arguments, as well as code_removed, since all three are polymorphic values. during type inference, a few additional arguments are added by the compiler as follows: code_removed (technically, even code_removed, being polymorphic, has additional arguments, but let's put that under the rug for readability's sake...) note that now it is clear what type code_removed should produce: it's code_removed, the same type which is produced by code_removed. in other words, code_removed asks its caller which type is wanted, and forwards the same type to code_removed. ditto for code_removed. by comparison, in code_removed there's no polymorphism in code_removed, but code_removed and code_removed are still polymorphic. during type inference the compiler reaches code_removed and has to invent code_removed and code_removed out of thin air, since code_removed is not asking them to its caller. hence the ambiguity error. finally, note that it is possible to see the additional type arguments which are added by ghc during type inference. to do that, it suffices to dump the ghc core intermediate language, e.g. with the code_removed ghc flag. in ghc 8.x, which is not yet released, rumors say that we will be even allowed to specify explicit type arguments in our code when we want to, and let the compiler infer them as usual otherwise. it sounds fun!", "as a previous comment asks, what are you trying to accomplish?", "@davidyoung thanks, typo fixed.", "in order to avoid infinite loops, the compiler normally requires that the constraints of an instance are \"smaller\" than the instance itself, so that the algorithm will terminate. your instance does not make code_removed any smaller in the constraints, so that's what the compiler is complaining about. the code_removed extension lifts this restriction, leaving it up to you to prove that it will terminate. it's thus possible to send the compiler into an infinite loop when using this extension. the common solution to this is to add a code_removed: code_removed now the constraints are smaller than the instance head, as they strip off the code_removed. no extension required.", "ohh, how silly of me. you want more than the format string to be useful obviously. well i think you'll need to add the instance into the printf module or use th.", "excellent answer! reading the part about transforming any algebra to a sum type which is a functor instance was an aha moment for me. do you have any references for it, or a \"mathy\" equivalent of it?", "i've got a ghc ticket now", "a few years ago, a pretty girl in our department decided to study computer science part-time. many people were surprised to discover one of the introductory courses was being taught using haskell as a/the programming language! although i didn't have experience with haskell, i had some background in lisp and other functional programming languages and was able to help her with her exercises. no, there's no happy end to this story: she dropped out, married somebody else and i haven't seen her in a long time. but i think the anecdote shows how knowledge can be useful when you least expect it. in more practical terms: you may have noticed that cpu speeds hit a wall some years ago, and now the most practical way to pull more performance from computers is by installing multiple cpus. now it so happens that most if not all of the programming languages you know are essentially single tasking, and subject to the von neumann bottleneck. an obvious solution is parallel programming, but that can be very painful if the parallel parts of your program end up sharing state, i.e. memory - and this is most often the case. it turns out that functional programming is a style that allows you to mostly circumvent the problems of parallel programming with shared state. stated differently, it's fairly easy to write programs in the fp style that are \"naturally\" thread safe and suitable for parallel processing. depending on the language, compiler and hardware you may even find (as i recently did) parts of your program running in parallel without ever having done any explicit coding for parallelism. i'm frequently wrong, but my guess is that functional programming will turn out to be one of the hot programming paradigms of the future as parallel programming becomes more important and more difficult. haskell may not turn out to be the language of choice - my personal favorite is currently clojure - but it may well be worthwhile to take a look at one or more fp languages.", "@andrewc thanks. but don't you agree that this not very natural in a mathematical sense?", "i was referring to the possibility of this being included in a cookbook not rwh. but thank you for the interesting link.", "@cmcdragonkai that depends on what your type looks like. you get an code_removed and you have to convert it to a variable of your type. it seems like you got confused over the terminology here. i think you mean your own type and not your own type class.", "also, this is a somewhat nuanced situation, because functions don't have to be fully \"executed\" in haskell. they just have to be expanded enough for whatever required value. consider code_removed, which takes the first element of an infinite list.", "@danm.: set can't be a monad because it's not even a functor, because it imposes structure on its members. ziplist doesn't \"look like\" a monad to me. one of the problems here is that \"looks like a monad\" is a very subjective question.", "see meta.stackexchange.com/questions/56669/\u2026, meta.stackexchange.com/questions/57226/\u2026, and related meta posts", "syntax extensions in ghc let you write this now: fib = 1: 1: [ a+b | a <- fib | b <- tail fib ]; however i'd write it 1:1:zipwith (+) fib (tail fib)", "i think it's mainly for consistency so that all clauses can be read in the same manner, so to speak; i.e. every rhs is at the same position in the type of the function. i think would mask quite a few silly errors if you allowed this, too. there's also a slight semantic quirk: say the compiler padded out such clauses to have the same number of patterns as the other clauses; i.e. your example would become code_removed now consider if the second line had instead been code_removed; in the absence of the previous clause, code_removed would be code_removed, but thanks to the eta-expansion performed here, it's code_removed \u2014 so code_removed does not actually define code_removed to be code_removed! this seems confusing enough to justify banning such clauses, imo.", "@davidyoung thanks, typo fixed.", "i personally think it's easier to explain/understand the existential notation in terms of its translation to the gadt form than on its own, but you are certainly free to think otherwise.", "@danielfischer i've verified that code_removed and code_removed produce different core. the former has an extra branch that compares against the word size (32 in my case). it doesn't seem to matter though, likely due to the branch taken always ends up being the same and thus can be predicted reliably (and thus be free). it's still a good practice to use code_removed if you know that the shift amount is smaller than the word size.", "solution you need the code_removed extension for this to work, like this: code_removed explanation if you have a type signature like this code_removed then it indicates that code_removed is polymorphic and works for any choice of code_removed. so code_removed could be used at type code_removed, or at type code_removed, or at type code_removed \u2013 whatever you like. if you have a type annotation like this code_removed it means a similar thing, namely that code_removed should be usable at any type of your choice. but that's not true in your case. the outer function code_removed is polymorphic, but within the function, code_removed has to be of the same type code_removed that the user has chosen for the outer code_removed. by default, haskell makes no connection between type variables occurring in different type signatures and annotations. however, you can tell it to do so by enabling the code_removed extension. now, by prefixing code_removed with code_removed, you can explicitly instruct haskell to make code_removed visible as a specific type variable within the definition of code_removed. if you then annotate code_removed, it refers to the outer code_removed rather than a new polymorphic code_removed.", "@conal: this answer is over a year old, and if there's anything i'd change in hindsight it would be to emphasize code_removed more heavily. it's probably the simplest structure that really shows the power of algebraic thinking and so much else is defined in terms of variations on monoids. i think i'd actually slip code_removed in alongside code_removed or code_removed, though, despite leaving code_removed for later.", "what the world needs is another monad blog post, but i think this is useful in identifying existing monads in the wild. monads are fractals the above is a fractal called sierpinski triangle, the only fractal i can remember to draw. fractals are self-similar structure like the above triangle, in which the parts are similar to the whole (in this case exactly half the scale as parent triangle). monads are fractals. given a monadic data structure, its values can be composed to form another value of the data structure. this is why it's useful to programming, and this is why it occurrs in many situations.", "great. thanks a lot!", "thanks very much for both the solutions. but i have another related question: why are the four leading blanks required in the second line (before addtwo)? and this has to be exact, if there are less or more blanks, then there is an error.", "also related: what does this syntax mean in haskell: \u22a5 or (\u22a5)", "i've put this as an answer rather than comment so it have some formatting: code_removed this is the same as the library module data.tree, although data.tree uses field-labels and a type synonym. i've seen both this tree and your first definition called \"rose trees\" although they have slightly different shapes so the terminology doesn't seem to be entirely precise. my interpretation is that it is the list \"[rose a]\" embedded in the single recursive constructor that is defining it as a rose tree.", "i've just finished reading lyahfgg cover to cover - super-highly recommended.", "@nikitavolkov for example, for lists, replacing code_removed with code_removed.", "exactly my thoughts!", "@sassanf you mean a feature has been recently added that would answer my main question? could you provide a link so i can read up on it?", "@mortenjensen the c assembly is 45 lines and the haskell is 2086!", "there is important difference between monad and monoid. monad is a rule to \"compose\" functions between different types, so they do not form a binary operation as required for monoids, see here for more details: stackoverflow.com/questions/2704652/\u2026", "@jhegedus: lifting /= applicative because you can lift without the applicative instance. but if you have an applicative then you can use the idiom above, and if you can write liftfoo2 then you can define the applicative instance. so its pretty close.", "no, it doesn't, although as you say code_removed does. there was another so question about why f# uses code_removed where haskell uses code_removed and code_removed, which is pretty relevant. (note also, just for fun, that with code_removed or code_removed, you can write your function point-free: code_removed, or code_removed.)", "what do you mean by \"you have not defined the function itself\"? the function is well defined and run if i remove the type annotation", "don't know haskell, but it's likely these are the same operation. code_removedulus == code_removedainder.", "you say in the paper you \"align with ghc's non-generalisation of local bindings\" - does that mean that partial type signatures won't work if you use the code_removed setting to allow those bindings to be generalised anyway?", "yeah, i felt the question was ambiguous and gave an answer for the case that hadn't already been answered.", "you could imagine an code_removed that builds the list the other order. but which should be code_removed or code_removed is unclear to me.:)", "what, no kiselyov style? when you think you really understand haskell, it's always good to read a bit of oleg's code.", "no, you don't need to hide anything, you don't need to import anything. if you copy the code (the two bits data... and instance....), it works as it is. it just adds a straightforward instance of the standard num typeclass, no cunning tricks.:)", "@ mikhail: hey, are you sure this works even if similar keyed values are not adjacent? for an example if dic = [(1,\"aa\"),(2,\"bb\"),(1,\"cc\")]? result should be [(1, [\"aa\",\"cc\"]), (2, \"bb\")].", "would be nice to see data.map discussed here too. this seems like a useful data structure especially for multi-dimensional data.", "@janustroelsen i don't know. hdbc does not seem to be developed nowadays, though. maybe \"persistent\" fills that role today.", "from haskell: haskell is a standardized, general-purpose purely functional programming language, with non-strict semantics and strong static typing. it is named after logician haskell curry. basically haskell can be used to create pretty much anything you would normally create using other general-purpose languages (e.g. c#, java, c, c++, etc.).", "how is this different than the code_removed operator which concatenates lists?", "@coolcodebro yeah, quasi-quoting is quite nice, and i suppose slightly orthogonal to th. (obviously it's implemented on top of th.) i was thinking more about using th to generate class instances, or build functions of multiple arities, or something like that.", "in the specific case of the ffi, code_removed is meant to be used for calling things that are mathematical functions, i.e. the output depends solely on the input parameters, and every time the function is called with the same inputs, it will return the same output. also, the function shouldn't have side effects, such as modifying data on disk, or mutating memory. most functions from code_removed could be called with code_removed, for example. you're correct that code_removed and pointers don't usually mix. for example, suppose you have code_removed even though you're just reading a value from a pointer, it's not safe to use code_removed. if you wrap code_removed, multiple calls can use the pointer argument, but get different results. it's necessary to keep the function in code_removed to ensure that it's sequenced properly in relation to pointer updates. this example should make clear one reason why this is unsafe: code_removed when compiled, this program outputs code_removed even though the value referenced by the pointer has changed between the two references to \"sin1\", the expression isn't re-evaluated, leading to stale data being used. since code_removed (and hence code_removed) is in io, the program is forced to re-evaluate the expression, so the updated pointer data is used instead.", "obviously if it should never be used, it wouldn't be in the standard libraries.;-) there are a number of reasons why you might use it. examples include: initialising global mutable state. (whether you should ever have such a thing in the first place is a whole other discussion...) lazy i/o is implemented using this trick. (again, whether lazy i/o is a good idea in the first place is debatable.) the code_removed function uses it. (yet again, it turns out code_removed is rather less useful than you might imagine.) perhaps most significantly, you can use it to implement data structures which are referentially transparent, but internally implemented using impure code. often the code_removed monad will let you do that, but sometimes you need a little code_removed. lazy i/o can be seen as a special-case of the last point. so can memoisation. consider, for example, an \"immutable\", growable array. internally you could implement that as a pure \"handle\" that points to a mutable array. the handle holds the user-visible size of the array, but the actual underlying mutable array is larger than that. when the user \"appends\" to the array, a new handle is returned, with a new, larger size, but the append is performed by mutating the underlying mutable array. you can't do this with the code_removed monad. (or rather, you can, but it still requires code_removed.) note that it's damned tricky to get this sort of thing right. and the type checker won't catch if it you're wrong. (what's what code_removed does; it makes the type checker not check that you're doing it correctly!) for example, if you append to an \"old\" handle, the correct thing to do would be to copy the underlying mutable array. forget this, and your code will behave very strangely. now, to answer your real question: there's no particular reason why \"anything withou pointers\" should be a no-no for code_removed. when asking whether to use this function or not, the only question of significance is this: can the end-user observe any side-effects from doing this? if the only thing it does is create some buffer somewhere that the user can't \"see\" from pure code, that's fine. if it writes to a file on disk... not so fine. hth.", "note: this answer should be read in combination with the one given by @luqui", "i think you meant \"why should code_removed be defined when code_removed can't be?\".", "this is a very old thread, but i think that code_removed in ruby & smalltalk is used because it is like you are \"injecting\" an operator between each element in the list. at least, that's how i always thought of it.", "+1 \"go\" being only 2 letters (and still meaningful) is a fact that is easy to under-appreciate. while i commented about the yesod book's use of \"go\" (which was an excellent name choice for those examples, imho), i was actually reading a stackoverflow answer that used \"go\" when i felt i should ask the question. i immediately remembered the yesod book example, though, because it was memorable. good stuff!", "never seen code_removed in any haskell material that i read. can you give an example/reference?", "@camccann, the question asked why haskell is called the best imperative language; comparing haskell to a crappy imperative language does not give us any information about the answer to that question:-)", "and that is yet another good reason to have spaces around code_removed (although the ugliness of code_removed should be enough;).", "code_removed this takes the action \"code_removed\" and stores the action in code_removed. code_removed this executes the action \"code_removed\" and stores the result of the action in code_removed. in the first example, code_removed is an unexecuted i/o action object. in the second example, code_removed is the contents of a file on disk.", "if you wanted \"zero, one, or both\" you'd have code_removed or code_removed.", "no, i won't because it's a clear cut answer. no wiggle room for opinions and such. i just want to know what the language was created for.", "the code_removed package has a strict version of the code_removed monad. you can find it here: the usage would look something like this: code_removed each time code_removed or bind code_removed is used, the two parts are evaluated using code_removed, giving a reasonable guarantee of strictness provided your data structure isn't too deep. this works, for i.e. numbers and basic structures.", "@devuxer i would argue that it does. i don't think anyone would realistically use fp for strict immutable code. instead, you decide where your mutability boundaries are, and work immutable on all the other levels - in this case, everyone can assume the state is immutable, except for that single tiny part that actually mutates the state. it's similar to how html works - yeah, you've got the immutable dom, but whenever you navigate, you still have to build a new one. code_removed is just an update function you pass to wherever you need to handle the gui updates - it's a latency fix.", "give hamlet a try- you might end up liking it. a negative reaction at a superficial level is not uncommon. however, nobody that has actually used hamlet complains. also, why not use happstack? just because they aren't \"in the news\" doesn't mean they don't have a solid framework.", "@viniciusseufitele, thanks for your comment. i'm afraid that my understanding hasn't advanced a great deal since i wrote this answer, so i can't really add much. the value extraction logically has to exist, so maybe that's why nobody bothers to mention it.", "@dan, indeed, there is provably no such algorithm (as long as you are using only element-element comparison; contrast radix sort)", "if traversing code_removed is much more expensive because it is a file on the network, couldn't you just always map the identity function over every input? your example then becomes, code_removed. now code_removed is stored in memory. optimizing the case where code_removed is used only once should be easy.", "this paper now at: the under-appreciated unfold", "it's pronounced \"good grief, they were really running out of operators, weren't they?\" also, a good name for code_removed might be code_removed.", "in practice, monad is a custom implementation of function composition operator that takes care of side effects and incompatible input and return values (for chaining).", "oh! and since code_removed is just a type family, code_removed is a data family which lets you avoid going around making new names for data types like code_removed, code_removed, code_removed, code_removed. it's just convenience to have both code_removed and code_removed.", "@woot4moo: 2.5 months is plenty of time to get \"comfortable\" with a language, though. doubly so if he's familiar with formal logic and working with abstract concepts from his philosophy background. not having to unlearn habits from other languages would also help in this case.", "@cheatex as far as i know, there is no standard. the names in my answer do reflect however what i heard other people use in colloquial settings, such as in #haskell on the irc.", "here's a nice little combinator: code_removed now we can write a pure function which checks your predicate and applies code_removed when appropriate: code_removed lifting this to an code_removed action is simply another code_removed: code_removed personally, i'd probably inline code_removed, and write that this way instead: code_removed ...which is a relatively clean description of what's happening.", "record syntax for updating exists, but quickly gets cumbersome. take a look at lenses instead.", "i can additionally recommend yet another haskell tutorial as an introduction. another good learning resource (probably on the intermediate level), which has helped me a lot and hasn't been mentioned in the other answers as far as i can see, is brent yorgey's typeclassopedia, which can be found in the monad reader (issue 13) it is written in a very accessible style and contains (among many other things), the following introductory advice: there are two keys to an expert haskell hacker\u2019s wisdom: understand the types. gain a deep intuition for each type class and its relationship to other type classes, backed up by familiarity with many examples. the monad reader itself is an absolute treasure trove for functional programmers (not only haskell programmers).", "but you should have used code_removed and code_removed or similar in order to not pretend that the record selectors are unused.", "why do you want to do this? if you tell us, perhaps we can give you a more useful answer than (the truthful) \"you can't\".", "very nice answer next to the other answers, but i think it would still benefit from a code example:)", "very interesting, thanks for the link!", "often it helps to just remove the type signature completely and let ghci tell you what it thinks the signature should be.", "thats my first example: with standard prelude (having typeclasses) gofer's error messages are more helpful than ghc's. example 2: one can expunge typeclasses completely if one chooses. so given that you concede that gofer's error messages (can be) better than ghc's, i dont know what's your point.", "great news about code_removed!", "@dmitri zitsev i have recently become better acquainted with monads and considering revising my treatment. your comment will like spur me on. i think i have the correct treatment now", "@vektorweg most of the work on the wikibook so far was done in the introductory chapters (which roughly cover the same ground as lyah level, though with a different take) and in the coverage of more advanced theory and type system topics. for applied issues, as seen in the later chapters of rwh swang refers to, rwh is a better choice for now; even though, as a wikibook contributor, i hope that will change eventually:)", "@anthony: the only thing called 'polycategories' that i know of doesn't seem to have any relevance here. could you clarify what connection you're seeing?", "that's a very good observation. i guess i just need more practice with haskell to get used to this kind of thing. thank you, and hopefully someone can answer all my 4 questions. still, +1.", "@mcb that depends on how you define \"different\". they're both errors, so in that sense they're the same. however you might argue, that they're different because they're presumably the result of different mistakes. that is code_removed could be the result of a simple typo (forgetting the code_removed before the code_removed), whereas code_removed is presumably the result of the code's author thinking that code_removed is a type and not a type class.", "if ghc already has the issue in their bug tracker, why would them coming here get a resolution any faster?", "ok, going over your answer in detail, now, i have to thank you, norman, from the bottom of my heart. a lot of stuff has fallen into place with a loud click now, and the stuff that i still don't understand i at least recognize that i'm not meant to understand it and will just pass over code_removed in those circumstances as, effectively, line noise. i'll look over that paper you linked to (thanks for the link as well!) and see if it's in my realm of comprehension. kudos.", "i am just starting to learn haskell so please forgive me if this question has an obvious answer. i'm interested in writing programs to distribute to end users who might know how to use their terminal application but not necessarily how to program or install haskell and haskell libraries on their system. how would one go about packaging up a haskell program (e.g. a command line tool or a more complex application) and distributing it to this sort of userbase?", "found this hackage.haskell.org/packages/archive/reverse-apply/latest/do\u200c\u200bc/\u2026", "@r.martinhofernandes: thanks for that link. it says that \"they are considered unassigned to any abstract character, and they share the general_category value cn (unassigned) with unassigned reserved code points in the standard\", so i don't think it's unreasonable to call them \"unassigned\". the faq seems to recommend that they be treated, when possible, like other unrecognized characters.", "given a deep embedding of a simple data processing dsl [1]: code_removed we can implement the familiar producer-consumer fusion like so code_removed a little example showing how it works: code_removed there's another, much less well known [2], type of fusion called sibling fusion, which removes multiple traversals of the same input. the idea is to replace something like code_removed with code_removed if traversing code_removed is much cheaper than traversing code_removed (e.g. if code_removed is a file on the network) or if we can e.g. use producer-consumer fusion to later fuse the untagging with some other traversal, this is a win. while producer-consumer fusion is easily implementable using our standard ast above, i don't see how to implement sibling fusion using this representation. code_removed an example of what we want to happen: code_removed the issue is that while we can easily spot consumer-producer fusion opportunities by pattern matching on code_removed, the two consumers of a single input which give rise to a sibling fusion opportunity aren't necessarily \"close\" to each other in the ast in the same way. if we could traverse the ast in the opposite direction i.e. starting from the code_removeds, parallel consumers of one input would be much easier to spot. i cannot see how to do this however given that each operation only refers to its input, not its output(s). question: can sibling fusion be implemented using this ast representation or is there some other (e.g. graph or continuation-based) representation that would allow us to implement sibling fusion? preferably while still using a gadt for type safety. this dsl is similar to the flumejava dsl for distributed computations: it's probably less well known because it's not clearly a win in single process programs, where additional bookkeeping may outweigh the cost of avoiding retraversing the input. however, if you're input is a 1tb file residing on the network it can be a very big win.", "do you know any online problem sets or contests that accept solutions in haskell? i know only el judge, but unfortunately it has some problems with ghc, so any haskell problem is rejected with \"memory limit\" resolution.", "@c.a.mccann: this is very interesting. what about defining code_removed only on nonempty lists? wouldn't it be a cleaner way to exclude the special case instead of \"accepting\" it and returning some error indicator?", "there are two ways to think of e: \u03c3. one is \"the expression e has type \u03c3\", another is \"the ordered pair of the expression e and the type \u03c3\". view \u03b3 as the knowledge about the types of expressions, implemented as a set of pairs of expression and type, e: \u03c3. the turnstile \u22a2 means that from the knowledge on the left, we can deduce what's on the right. the first rule [var] can thus be read: if our knowledge \u03b3 contains the pair e: \u03c3, then we can deduce from \u03b3 that e has type \u03c3. the second rule [app] can be read: if we from \u03b3 can deduce that e_0 has the type \u03c4 \u2192 \u03c4', and we from \u03b3 can deduce that e_1 has the type \u03c4, then we from \u03b3 can deduce that e_0 e_1 has the type \u03c4'. it's common to write \u03b3, e: \u03c3 instead of \u03b3 \u222a {e: \u03c3}. the third rule [abs] can thus be read: if we from \u03b3 extended with x: \u03c4 can deduce that e has type \u03c4', then we from \u03b3 can deduce that \u03bbx.e has the type \u03c4 \u2192 \u03c4'. the fourth rule [let] is left as an exercise.:-) the fifth rule [inst] can be read: if we from \u03b3 can deduce that e has type \u03c3', and \u03c3' is a subtype of \u03c3, then we from \u03b3 can deduce that e has type \u03c3. the sixth and last rule [gen] can be read: if we from \u03b3 can deduce that e has type \u03c3, and \u03b1 is not a free type variable in any of the types in \u03b3, then we from \u03b3 can deduce that e has type \u2200\u03b1 \u03c3.", "@andrewc: as for gofer using overloaded numeric literals: heres chap 14.4.4 of the gofer docs: in haskell, any integer constant k appearing in an expression is treated as if the programmer had actually written \"frominteger k\"... gofer does not support any form of default mechanism and overloaded numeric constants can only be obtained by explicit use of the frominteger function", "because someone could define lists to be treated as numbers: code_removed then what you typed would work, since code_removed (not that this code_removed instance would make much sense..)", "steven pemberton wrote 2 great posts on f# and wpf, his thoughts on wpf development with f# towards the end of the second post adds to this discussion. 2 other examples that also intrigued me were the use of a functional controller in event driven mvvm and the use of discriminated unions and recursion for constructing a simple interface in the wpf controls demo by flying frog consultancy.", "it happens because the values are determined at run time. it can bring about a transformation of values depending on what are entered at run time hence it assumes that the hole is already updated.", "i will try to explain code_removed in the context of haskell. in functional programming, function composition is important. it allows our program to consist of small, easy-to-read functions. let's say we have two functions: code_removed and code_removed. we can do code_removed, which is just the same as code_removed, where code_removed is an code_removed value. when doing composition/applying the result of one function to another, having the types match up is important. in the above case, the type of the result returned by code_removed must be the same as the type accepted by code_removed. but sometimes values are in contexts, and this makes it a bit less easy to line up types. (having values in contexts is very useful. for example, the code_removed type represents an code_removed value that may not be there, the code_removed type represents a code_removed value that is there as a result of performing some side effects.) let's say we now have code_removed and code_removed. code_removed and code_removed are very similar to code_removed and code_removed respectively. we can't do code_removed or code_removed, where code_removed is an code_removed value. the type of the result returned by code_removed is not what code_removed expects. we could compose code_removed and code_removed with the code_removed operator, but now we can't compose code_removed and code_removed with code_removed. the problem is that we can't straightforwardly pass a value in a context to a function that expects a value that is not in a context. wouldn't it be nice if we introduce an operator to compose code_removed and code_removed, such that we can write code_removed? code_removed returns a value in a context. the value will be taken out of context and applied to code_removed. and yes, we have such an operator. it's code_removed. we also have the code_removed operator that does for us the exact same thing, though in a slightly different syntax. we write: code_removed. code_removed is a code_removed value. the code_removed operator helps take that code_removed value out of the \"perhaps-not-there\" context, and apply it to code_removed. the result of code_removed, which is a code_removed, will be the result of the entire code_removed operation. and finally, why is code_removed useful? because code_removed is the type class that defines the code_removed operator, very much the same as the code_removed type class that defines the code_removed and code_removed operators. to conclude, the code_removed type class defines the code_removed operator that allows us to pass values in a context (we call these monadic values) to functions that don't expect values in a context. the context will be taken care of. if there is one thing to remember here, it is that code_removeds allow function composition that involves values in contexts.", "\"applicative is almost the same as monads, except that effects cannot depend on previous results.\"... a lot of stuff clicked into place for me with this line, thanks!", "it's probably worth mentioning, that since the code_removed type class provides the code_removed function, which has this type signature: code_removed, you can define code_removed as code_removed and then code_removed. the code.", "the decorate-process-undecorate approach seems like a lot of extra work for this problem.", "@niklas, wouldn't it still hold? i mean if last [] = []", "the first proper functional programming project i wrote was for rapid prototyping of z specifications in orwell. implementing the maths library in dictionary passing style was very annoying indeed, sometimes with more dictionaries than actual arguments. switching to gofer's type classes was a huge relief.", "code_removed would be more readable.", "@serpentine cougar, chris p: yep, it\u2019s what i meant.", "@chrisnash - 1) it wouldn't work. reference count-base reclamation leaks data if there are cycles... unless you can rely on application code to break the cycles. 2) it is well known (to people who study these things) that reference counting performs poorly when compared with a modern (real) garbage collector.", "these are books, not real project's source files.", "the source code to the yesod web platform is fairly complex, well thought out, and well written. you will learn a lot from the persistence library that comes with it as well.", "so what do you do if you don't want seeds, because you want a hardware rng instead?", "you say 1 + 2 is not nf, however you also say 1 + 2 is not whnf, so what is it?", "the key are the records: notice code_removed, code_removed. whenever we lookup a variable from the environment, we actually get back a record, which we dereference to see if it's a thunk. if it is a thunk, we evaluate it and then save the result. we create thunks during application (notice the call to the code_removed constructor), recursive definitions and pattern matching, because those are constructs that bind variables.", "+1 wow, been using haskell for years and never noticed that such definition is not allowed!", "why is there an code_removed in code_removed? is it only for symmetry with code_removed, or is there some other reason this unfolds should be considered to be right associative? this came up when i was considering adding an unfold to code_removed, where i couldn't think of a reason to include an code_removed in the name. code_removeds have both right and left folds. i don't see a reason why the unfold would be more right than left.", "the haskell approach seems to be to just wrap imperative gui toolkits (such as gtk+ or wxwidgets) and to use \"do\" blocks to simulate an imperative style that's not really the \"haskell approach\" -- that's just how you bind to imperative gui toolkits most directly -- via an imperative interface. haskell just happens to have fairly prominent bindings. there are several moderately mature, or more experimental purely functional/declarative approaches to guis, mostly in haskell, and primarily using functional reactive programming. some examples are: reflex-platform, grapefruit, reactive, wxfruit, reactive-banana, for those of you not familiar with haskell, flapjax, is an implementation of functional reactive programming on top of javascript.", "\"compiles to assembly\"... well, eventually. ghc produces cmm, llvm bitcode, or c, and those get converted to assembly. the code that converts those irs to assembly are not actually part of the ghc project itself, maybe with the exception of cmm (not sure).", "this document gives a good overview of the strong and weak points of the haskell ecosystem.", "in the specific case of the ffi, code_removed is meant to be used for calling things that are mathematical functions, i.e. the output depends solely on the input parameters, and every time the function is called with the same inputs, it will return the same output. also, the function shouldn't have side effects, such as modifying data on disk, or mutating memory. most functions from code_removed could be called with code_removed, for example. you're correct that code_removed and pointers don't usually mix. for example, suppose you have code_removed even though you're just reading a value from a pointer, it's not safe to use code_removed. if you wrap code_removed, multiple calls can use the pointer argument, but get different results. it's necessary to keep the function in code_removed to ensure that it's sequenced properly in relation to pointer updates. this example should make clear one reason why this is unsafe: code_removed when compiled, this program outputs code_removed even though the value referenced by the pointer has changed between the two references to \"sin1\", the expression isn't re-evaluated, leading to stale data being used. since code_removed (and hence code_removed) is in io, the program is forced to re-evaluate the expression, so the updated pointer data is used instead.", "fair warning: i'm the lead developer of yesod. i'm not sure what you don't like about the javascript syntax: it is plain javascript with variable interpolation. as for css yesod now has lucius which allows you to also use plain css. for html, you can easily use any other library you want, including heist (what snap uses). that said, it's a bit of a funny thing to skip yesod over css/javascript syntax, when snap doesn't even have a syntax for it. you are certainly welcome to their solution of just static files. yesod comes with seamless support for authentication/authorization, type-safe urls, widgets, email, and a bunch of little things all over the place (breadcrumbs, messages, ultimate destination). plus, yesod has a fairly rich set of add-on packages for things like comments and markdown, and a few large real-world code bases to pick at for examples. if any of these are attractive to you, you might want to check if your alternatives supports them.", "you can avoid \"empty list\" exceptions with some smart pattern matching. code_removed this is simply syntax sugar for the following code_removed the pattern matching is done in order, so code_removed will be matched against the pattern code_removed first. then if that fails, the catch-all pattern code_removed will succeed.", "if they are windows users then use the bamse package to build an installer for your application. if not then look for distro-specific packaging suggestions. perhaps someone else can explain os x packaging.", "really cool solution. never would've thought of it, but it makes a lot of sense, considering the nature of data.map.", "@laurencegonsalves i think you are conflating two separate things: first, the question, \"can we justify the existence of monads?\"; and second, \"please help me understand what a monad is.\" all of my comments in this answer are meant to help (if only in a small way) towards question # 2. i'm not really much interested in discussing question # 1 (perfectly valid question, just not something i am all that interested in). so my comment about dsl's is not an argument in favor of monads, and therefore presenting evidence would be out of place.", "technically, code_removed is not equivalent to code_removed when code_removed is enabled. when the code_removed is there, it affects code_removed's code_removed clause (if it has one) and changes the meaning of type variables named code_removed in it.", "so, coalgebras seem to fit as a better, first-class substitute of haskell modules, so that we can construct various coalgebras satisfying an interface (= a signature, or better -- a \"cosignature\"? since a \"signature\" is what an algebra has) and pass them as parameters to functions which depend the particular interface of a module that wish to use...", "cs.coloradocollege.edu/~bylvisaker/monadmotivation", "you should use, e.g., hp2ps to get a graphical view of what's going on. looking at the raw hp file is difficult.", "@sjoerd visscher: don't get me wrong. i like point. it is an interesting type. it can also be useful to describe things like aggregators that add a number to a counter, etc. but are no laws for reasoning about what would form a valid point as opposed to a valid lens, because get and put have become unrelated. hence 'lawless'.;) as a side note, fmapl doesn't generate valid lenses by the lens laws. i realized that when i added scalacheck properties to my lenses in scala.", "@ganeshsittampalam ohhhh i see what you mean, i crashed into that wall of higher-kindedness. but you realize that posing things like this is a little silly because you are in oop, so actually the code_removed in code_removed of code_removed is the known by the actual object, and that code_removed is actually going to be a code_removed, so you can reduce this to code_removed.", "what does weak head normal form (whnf) mean? what does head normal form (hnf) and normal form (nf) mean? real world haskell states: the familiar seq function evaluates an expression to what we call head normal form (abbreviated hnf). it stops once it reaches the outermost constructor (the \u201chead\u201d). this is distinct from normal form (nf), in which an expression is completely evaluated. you will also hear haskell programmers refer to weak head normal form (whnf). for normal data, weak head normal form is the same as head normal form. the difference only arises for functions, and is too abstruse to concern us here. i have read a few resources and definitions (haskell wiki and haskell mail list and free dictionary) but i don't get it. can someone perhaps give an example or provide a layman definition? i am guessing it would be similar to: code_removed how do code_removed and code_removed relate to whnf and hnf? update i am still confused. i know some of the answers say to ignore hnf. from reading the various definitions it seems that there is no difference between regular data in whnf and hnf. however, it does seem like there is a difference when it comes to a function. if there was no difference, why is code_removed necessary for code_removed? another point of confusion is from the haskell wiki, which states that code_removed reduces to whnf, and will do nothing to the following example. then they say that they have to use code_removed to force the evaluation. is that not forcing it to hnf? common newbie stack overflowing code: code_removed people who understand seq and weak head normal form (whnf) can immediately understand what goes wrong here. (acc+x, len+1) is already in whnf, so seq, which reduces a value to whnf, does nothing to this. this code will build up thunks just like the original foldl example, they'll just be inside a tuple. the solution is just to force the components of the tuple, e.g. code_removed -haskell wiki on stackoverflow", "@j.abrahamson just wanted to note, that code_removed doesn't have a monadic but an applicative interface.", "template haskell code sometimes looks for identifiers beginning with an underscore. for instance, underscores are used to automate lens generation.", "ghc.haskell.org/trac/ghc/wiki/overloadedlists", "i recently started a little hobby project, where i try to implement the trick-taking card-game skat (for 3 players). to make it possible to have different kinds of players (like ai, network and local) playing together, i designed an interface using a typeclass code_removed: code_removed i use a code_removed to wrap up those three players: code_removed but now, i have to write a big pile of context in each type signature: code_removed how can i avoid writing this big context again and again?", "function code_removed must have the same type of code_removed and code_removed. so, when we write code_removed, we must use code_removed type in code_removed code_removed", "on the machine i am on right now, code_removed gives 9223372036854775807, so here code_removed is 64 bits. maybe the op has installed a 32 bit version of ghc on a 64 bit os?", "very interesting, thanks for the link!", "you might find this interesting/relevant: blog.lab49.com/archives/3011", "thanks for the reminder about code_removed. i'm with you there. simple & general.", "@immibis no it doesn't, you could have torn writes", "haskell cannot be a good general purpose language for rapid application development. each of python,javascript,go, c#, java,and swift are useful primarily for more specific purposes in addition to general development. if haskell is good for \"rapid application development\", that means it's good for nothing in particular.", "@edwardkmett i was just pointing out a feature that fclabels has that is unique among the lenses packages (afaik), and therefore should be mentioned in a thorough comparison. perhaps the documentation should mention that code_removed only creates proper lenses with container types with a fixed number of 'holes', like code_removed, which have a zip-like code_removed instance. however, the lens that is created is the most natural one possible for code_removed, in some vague sense that should probably be made more concrete.", "problematic? they shouldn't be used for everything, and the standard array modules aren't very pleasant, but vector is very useful when it's applicable. though i agree that proficiency with lists should be attained before trying to use them...", "why doesn't it work in ghci? why is there a difference in the syntax?", "in fact, there exists a showcase android app written in java and frege, details are here groups.google.com/forum/#!topic/frege-programming-language/\u2026", "thanks for the thorough answer, @bdonlan. this is what i'm looking for.", "i said that in ghc it works. maybe in any other haskell compiler it is parsed as i said.", "i haven't actually tried fixing the situation since then.", "@alexeyshmalko sure, you can continue to optimize whichever language's implementation and compiler. see raedwulf's answer for example.", "note also that code_removed:)", "if you enable undecidableinstances, flexibleinstances is superfluous.", "very nice writeup! what do you think about the fields library?", "@raxacoricofallapatorius, please see my answer for some explanation of where the whole \u22a5 thing comes from. it is correct that if you don't use it, it won't be evaluated. the primary driver of evaluation is pattern matching. code_removed will not evaluate code_removed because code_removed is only used to define code_removed, and nobody ever looks at code_removed. change that to code_removed, and suddenly code_removed is strict in code_removed.", "project euler", "\"learning haskell will ruin all other languages for you.\" so true. before i wrote in haskell, i was thinking for every project i started \"ok, what language will that be in?\". now i'm not even considering anything else than haskell (except possibly agda or idris). to be fair, i don't know whether that's so much of a contra. a lot does indeed work better in haskell. the main problem of only working in haskell is that there are good libraries and frameworks for specific tasks that one can't use without effort, because they are in a different language (say, node.js etc.)", "ok, going over your answer in detail, now, i have to thank you, norman, from the bottom of my heart. a lot of stuff has fallen into place with a loud click now, and the stuff that i still don't understand i at least recognize that i'm not meant to understand it and will just pass over code_removed in those circumstances as, effectively, line noise. i'll look over that paper you linked to (thanks for the link as well!) and see if it's in my realm of comprehension. kudos.", "@danielwagner isn't converting every element to a list and then concatenating lists kinda expensive?", "technically, code_removed is not equivalent to code_removed when code_removed is enabled. when the code_removed is there, it affects code_removed's code_removed clause (if it has one) and changes the meaning of type variables named code_removed in it.", "using the same technique used in your post, you can do: code_removed see it in action: code_removed does that help?", "your code_removed example seems more complicated than one in a modern imperative language; wouldn't you rather use a syntax-sugared iterator-foreach loop, instead of manually traversing your list with a code_removed-construct (requiring you to manually manage the iteration variable)? -- and btw, wouldn't a literal java-syntax translation using a code_removed construct look complicated as well?", "@nponeccop: hmm, good point. i haven't actually seen that particular rule before. could you help me explain it properly?", "an obvious generalisation like code_removed:)", "start writing code. you'll learn necessary concepts as you go. beyond the language, to use haskell effectively, you need to learn some real-world tools and techniques. things to consider: cabal, a tool to manage dependencies, build and deploy haskell applications*. ffi (foreign function interface) to use c libraries from your haskell code**. hackage as a source of others' libraries. how to profile and optimize. automatic testing frameworks (quickcheck, hunit). *) cabal-init helps to quick-start. **) currently, my favourite tool for ffi bindings is bindings-dsl.", "actually it's not the inference that did it. that only helps you a) debug or avoid type problems and typeclass instance selection problems b) debug and avoid some undecidable type problems with a few modern language extensions. it also helps you to make your programs uncomposable so you can never scale up your development efforts.", "both. the fact that the data referred to is immutable follows from the fact that all the references are immutable, all the way down.", "with code_removed, the type code_removed doesn't contain the polymorphic code_removed variable. to actually compute the code_removed result, the code_removed needs to be instantiated, and the resulting code_removed value can depend on the choice of code_removed (through the code_removed instance), so instead of making an arbitrary choice ghc refuses to compile. with code_removed, the code_removed parameter is in the type of the result, therefore there is no ambiguity. the choice for code_removed has not yet been made, we can still instantiate code_removed as we like (or more precisely, we re-generalized the type of code_removed).", "another odd thing is that if i ask ghci code_removed, it tells me code_removed, but if i ask code_removed, it tells me code_removed. so something seems to be very strange about how the parser handles code_removed.", "@danielfischer: agreed. i put them under \"misc\" together with monoid. feel free to move stuff around if you have a better suggestion.", "wow, i've been looking for that for ages!", "haskell wiki seems to be pretty beginner friendly on this topic.", "yeah, i felt the question was ambiguous and gave an answer for the case that hadn't already been answered.", "i'm learning haskell and read a couple of articles regarding performance differences of haskell lists and (insert your language)'s arrays. being a learner i obviously just use lists without even thinking about performance difference. i recently started investigating and found numerous data structure libraries available in haskell. can someone please explain the difference between lists, arrays, vectors, sequences without going very deep in computer science theory of data structures? also, are there some common patterns where you would use one data structure instead of another? are there any other forms of data structures that i am missing and might be useful?", "great explanation! what i don't understand is if code_removed is erased after compilation and runtime uses the same representation for old and new types, how can we still be able to define instances for both old and new type? how can runtime understand which instance to use?", "@edwardkmett: i saw that the lense package only uses the exitcode-stdio-1.0 test suite interface. the cabal user guide states, that ``it is preferred that new test suites be written for the detailed-1.0 interface''. any comments on that?", "code_removed isn't an operator, it's a keyword, like code_removed or code_removed, so i think you could only alter the precedence using parentheses. see more here:", "@duosrx, thanks for the suggestions, they seem to make sense. your comment could be an answer btw;)", "an indexed monad isn't a specific monad like, for example, the state monad but a sort of generalization of the monad concept with extra type parameters. whereas a \"standard\" monadic value has the type code_removed a value in an indexed monad would be code_removed where code_removed and code_removed are index types so that code_removed is the type of the index at the beginning of the monadic computation and code_removed at the end of the computation. in a way, you can think of code_removed as a sort of input type and code_removed as the output type. using code_removed as an example, a stateful computation code_removed maintains a state of type code_removed throughout the computation and returns a result of type code_removed. an indexed version, code_removed, is a stateful computation where the state can change to a different type during the computation. the initial state has the type code_removed and state and the end of the computation has the type code_removed. using an indexed monad over a normal monad is rarely necessary but it can be used in some cases to encode stricter static guarantees.", "you certainly can ffi into libc without io. the outcome will be unexpected or nondeterministic. \"why not do it the simple way?\" is because the entire point of haskell is that you can't do it the simple way - if you allow side effects the simple way, then haskell is just another imperative language with different syntax (similar to c or python).", "@dfeuer it's not really doing anything essential.", "i always liked code_removed. take a value and wrap it in a functor, applicative, monad. it also works well when used in a sentence with concrete instances: code_removed, code_removed, etc. \"it takes a value and wraps it in a code_removed\".", "@davidyoung yes, i agree. interestingly, code_removed returns code_removed, so i'm not sure what happens to code_removed - is it treated as infinity but shown as code_removed, or if code_removed are defaulted when it is one of the arguments.", "@dietrich epp: there's also only one code_removed, but asking whether empty lists of different types are equal remains nonsense; also, i'm not sure if semantic uniqueness actually justifies using code_removed in... equivalences? equalities? identities? whatever type class laws actually are, if that's even well-defined (i'm actually pretty sure they can't be identities). the code_removed instance is far less questionable because it dodges the issue by merely preserving an existing code_removed rather than introducing or removing code_removed values.", "+1 - to be clear: do not learn it just with the irc channel. as in, don't go in and ask \"how do i write a haskell program? how do i add numbers?\"", "this is the best and most grokkable explanation of monads and their mathematical background of monoids i have come across in literally weeks. this is what should be printed in every haskell book when it comes to monads, hands down. upvote! maybe further get the piece of information, that monads are realized as parameterized typeclass instances wrapping whatever put in them in haskell, into the post. (at least that is how i understood them by now. correct me if i am wrong. see haskell.org/haskellwiki/what_a_monad_is_not )", "data.ord code_removed (for those wondering about the writing the code_removed shorter)", "@mljrg no, you can't have just any kind of expression on the lhs, that would add a lot of complexity. this is just a shorthand for writing code_removed or code_removed.", "sjoerd: what you are looking for is the preservation of limits. representable functors have this property, see the representable-functors package. while the definition for maybe given by fmapl is 'as close to a lens as you can get' it still isn't a lens.;)", "haha yeah, i'm sure the paper is where i got a fair bit of my chronology from...", "this is called record syntax, lyah has a good section on it (ctrl-f for \"record syntax\"). when a datatype is defined with records, haskell automatically defines functions with the same name as the record to act as accessors, so in this case code_removed is the accessor for the age field (it has type code_removed), and similarly for code_removed and code_removed. these are normal haskell functions and so are called like code_removed or code_removed.", "here is a quick and dirty explanation in plain terms that you're likely to be already familiar with. the code_removed keyword is really only used in one way in haskell. it always means the same thing when you see it. universal quantification a universally quantified type is a type of the form code_removed. a value of that type can be thought of as a function that takes a type code_removed as its argument and returns a value of type code_removed. except that in haskell these type arguments are passed implicitly by the type system. this \"function\" has to give you the same value no matter which type it receives, so the value is polymorphic. for example, consider the type code_removed. a value of that type takes another type code_removed and gives you back a list of elements of that same type code_removed. there is only one possible implementation, of course. it would have to give you the empty list because code_removed could be absolutely any type. the empty list is the only list value that is polymorphic in its element type (since it has no elements). or the type code_removed. the caller of such a function provides both a type code_removed and a value of type code_removed. the implementation then has to return a value of that same type code_removed. there's only one possible implementation again. it would have to return the same value that it was given. existential quantification an existentially quantified type would have the form code_removed, if haskell supported that notation. a value of that type can be thought of as a pair (or a \"product\") consisting of a type code_removed and a value of type code_removed. for example, if you have a value of type code_removed, you have a list of elements of some type. it could be any type, but even if you don't know what it is there's a lot you could do to such a list. you could reverse it, or you could count the number of elements, or perform any other list operation that doesn't depend on the type of the elements. ok, so wait a minute. why does haskell use code_removed to denote an \"existential\" type like the following? code_removed it can be confusing, but it's really describing the type of the data constructor code_removed: code_removed once constructed, you can think of a value of type code_removed as consisting of two things. it's a type code_removed together with a value of type code_removed. in other words, it's a value of an existentially quantified type. code_removed could really be written as code_removed, if haskell supported that notation. code_removed and friends given that, how are these different? code_removed let's first take code_removed. it takes a type code_removed and a function of type code_removed, and produces a value of type code_removed. we could choose code_removed as the code_removed and give it a function of type code_removed for example. but code_removed is different. it requires that the implementation of code_removed be able to pass any type it wants to the function we give it. so the only function we could reasonably give it is code_removed. we should now be able to tackle the meaning of the type of code_removed: code_removed so code_removed has to be able to produce a value of type code_removed, no matter what type we give as code_removed. to do so, it needs an argument of type code_removed which under the hood is just a function of type code_removed. that function then has to be able to produce a value of type code_removed no matter what type the implementation of code_removed decides to give as code_removed. ok, so what? the benefit is that this puts a constraint on the caller of code_removed in that the type code_removed cannot involve the type code_removed at all. you can't pass it a value of type code_removed, for example. what that means in practice is that the implementation of code_removed is free to perform mutation with the value of type code_removed. the type system guarantees that this mutation is local to the implementation of code_removed. the type of code_removed is an example of a rank-2 polymorphic type because the type of its argument contains a code_removed quantifier. the type of code_removed above is also of rank 2. an ordinary polymorphic type, like that of code_removed, is rank-1, but it becomes rank-2 if the types of arguments are required to be polymorphic, with their own code_removed quantifier. and if a function takes rank-2 arguments then its type is rank-3, and so on. in general, a type that takes polymorphic arguments of rank code_removed has rank code_removed.", "for high-level networking, i prefer network-simple.", "haskell doesn't have dot notation for record members. for each record member a compiler creates a function with the same name with a type rectype -> fieldtype. this leads to name conflicts. are there any ways to work around this, i.e. how can i have several records with the same field names?", "the straight answer was already given: use code_removed. however newbies often tend to overuse this operator, which is expensive in haskell (because you work on single linked lists, not on arrays). there are several useful techniques to avoid this, the easiest one is using zip. if you write code_removed, you get a new list with the indices \"attached\" to each element in a pair: code_removed, which is often exactly what you need.", "i suppose to answer this question for posterity -- \"when the program was built without profiling enabled, they ran exactly the same\". this makes perfect sense as additional function calls that are inlined away nonetheless, when profiling is enabled, must leave some trace for a cost center. heisenberg's principle in action -- if we observe our program too closely, we end up changing it!", "i like this approach. so, the way to handle state for the players is to use a more general function like code_removed and use partial application? okay, i think i got it. ps: you are missing an code_removed after code_removed, but i don't know, whether this is intentional. (maybe a code_removed works as well?)", "please optimize your code, or get others to help you do so, before asking questions like #1 and #2.", "the \"world object\" was just a pun:)", "is it possible to set the precision of the measured time, like in milliseconds?", "its a good question, and i'm not aware of any answers. perhaps we need a naming scheme, or perhaps library authors should provide pronounceable names as part of haddock docs.", "care to give me an example?", "best practice is to put the version number in your cabal file, as you have already noted. i am not aware of any good practices by which you can maintain a single point of truth about the version, yet make the number available both to cabal and to your application. i would recommend a single file code_removed in the sources with these contents: code_removed you could then, if you wished, use some kind of script to update the cabal file with this number, but i don't know how to do this from within cabal itself. this strategy will work only for application packages; if you are building a library, you'll need to give some thought to where in the namespace of hierarchical modules your code_removed will go. on the whole, i suspect the game is not worth the candle. p.s. the version number should be immutable, so you want a value, not a function.", "what do you mean by \"standard\" version?", "but this is obviously wrong. no, it's completely correct. the type of code_removed is code_removed and the type of integer literals is code_removed so the type code_removed that an argument of code_removed must have is unified with the type code_removed that a literal has, giving code_removed and if you have a list type with a code_removed instance, that expression can also be evaluated. but, by default, there is no code_removed instance for list types available, so when you try to evaluate it, ghci complains that it finds no code_removed instance for code_removed. for example: code_removed", "monads are just a convenient framework for solving a class of recurring problems. first, monads must be functors (i.e. must support mapping without looking at the elements (or their type)), they must also bring a binding (or chaining) operation and a way to create a monadic value from an element type (code_removed). finally, code_removed and code_removed must satisfy two equations (left and right identities), also called the monad laws. (alternatively one could define monads to have a code_removed instead of binding.) the list monad is commonly used to deal with non-determinism. the bind operation selects one element of the list (intuitively all of them in parallel worlds), lets the programmer to do some computation with them, and then combines the results in all worlds to single list (by concatenating, or flattening, a nested list). here is how one would define a permutation function in the monadic framework of haskell: code_removed here is an example repl session: code_removed it should be noted that the list monad is in no way a side effecting computation. a mathematical structure being a monad (i.e. conforming to the above mentioned interfaces and laws) does not imply side effects, though side-effecting phenomena often nicely fit into the monadic framework.", "keep in mind that this hack with these extensions only works reasonably safely within a single module. you can't even use exports from this module even if you don't export myclass, in any other module that will ever have a module that transitively depends upon it that ever wants to show anything that isn't an instance of myclass.", "@hvr, i've added a contrasting example in python to demonstrate my point. it's not perfectly idiomatic python; i'm trying to boil down the function to what i consider the essence of imperative programming: looping and assignment.", "this may be fixed real soon now in ghc. i think its a gsoc project:d", "you left out code_removed!", "increasing the value to 1000 as below does not obtain the correct result. with > 500 as above, newest test: intelcore2 cpu 6600 @ 2.40ghz comletes in real 0m2.370s", "the exact reason is because it's totally unnecessary. why would you need a one-tuple if you can just have its value? the syntax also tends to be a bit clunky. in python, you can have one-tuples, but you need a trailing comma to distinguish it from a parenthesized expression: code_removed all in all, there's no reason for it. i'm sure there's no \"official\" reason because the designers of haskell probably never even considered a single element tuple because it has no use. i don't know if you were looking for some reasons beyond the obvious, but in this case the obvious answer is the right one.", "you might find this interesting/relevant: blog.lab49.com/archives/3011", "@konrad: they do the same thing in the sense that both use type system features to abstract side effects, but that's about it. note that it's very well to explain the io monad in terms of a world type, but the haskell standard doesn't actually define a world type and it's not actually possible to get a value of type world in haskell (while it's very possible and indeed necessary in clean). further haskell does not have uniqueness typing as a type system feature, so if it did give you access to a world, it could not ensure that you use it in a pure way the way clean does.", "what do you want to write, what type of applications? what problems do you want to solve? there are some problem types that haskell will excel in, but, if you write a program that requires constantly changing state then haskell is a bad choice. if while modeling the problem it doesn't fit well with functional programming, such as writing a cad (computer-aided design) program, oop would be a better choice, just because the programming paradigm fits better with the model. but, if you are not affected by these problems then haskell can be a great language to use.", "i am by no mean an android expert. but today i came across this new class called nativeactivity since api level 9 developer.android.com/reference/android/app/nativeactivity.h\u200c\u200btml. they say it can be used for implementing activities purely in native code. i wonder how relevant/useful this is for our purpose? does this imply no need for interaction between haskell and java?", "that's clearly not the whole story. yes, code_removed in a pattern is syntax, but in other contexts it's a type operator.", "@dlkulp code_removed concatenates one list to another. with code_removed the first argument is of type code_removed (an arbitrary type) and the second argument is of type code_removed which is the type of lists of elements of code_removed.", "@bmeph code_removed, code_removed, code_removed are the synonyms. by saying \"function waits\" i meant \"function anticipates\".", "i think the code_removed metaphor doesn't work very well when starting to think about concurrency. when forking an io action, does that mean that the entire world is copied? if so, how is it joined again? an analogy to an abstract version of java's code_removed might be better (i.e. code_removeds which you can never run yourself but only bind to functions to produce new runnables).", "@raxacoricofallapatorius: code_removed is just a variable, but with one trick up its sleeve: ghc's code_removed feature, which warns of unused variables, skips variables that start with underscore. so what's happening there is that the code in question is compiled with that option, and the use of that name shuts off the warning. why use that instead of just code_removed? i don't know the author's motive, but it's almost certainly a stylistic thing.", "do you have an updated link for that paper? the one listed is broken.", "the code_removed package provides the means for a very simple implementation: code_removed", "code_removed has a higher-rank type and type inference for higher-rank types is very limited. it might be a little easier to understand (but much longer!) if we expand the type synonym: code_removed the higher-rank types of code_removed and code_removed are specified explicitly in this type signature. this lets the type inference start already knowing the types of code_removed and code_removed and so being able to unify them with the type of code_removed. however, if you get rid of code_removed and code_removed, the type that code_removed has to take is not known. unfortunately, the system can't infer higher-rank types like this, so you get a type error. in essence, the compiler can't create higher-rank types to fill unknowns during type inference and has to rely on programmer annotations and we need both the name (code_removed and code_removed) and the type signature to get those annotations. an easier example to understand would be a higher-rank code_removed function: code_removed the definition code_removed compiles, but code_removed gives the following error: code_removed (keep in mind that code_removed is the same as code_removed.)", "@kqr: i thought about mentioning that:-) but in a rare moment of concision, i decided my answer was long enough already!", "\"applicative is almost the same as monads, except that effects cannot depend on previous results.\"... a lot of stuff clicked into place for me with this line, thanks!", "", "both of these \"fixes\" look rather fragile to me. am i missing something?", "two great examples, i hadn't thought about these use cases.", "(see also the answers at what is a monad?) a good motivation to monads is sigfpe (dan piponi)'s you could have invented monads! (and maybe you already have). there are a lot of other monad tutorials, many of which misguidedly try to explain monads in \"simple terms\" using various analogies: this is the monad tutorial fallacy; avoid them. as dr maciver says in tell us why your language sucks: so, things i hate about haskell: let\u2019s start with the obvious. monad tutorials. no, not monads. specifically the tutorials. they\u2019re endless, overblown and dear god are they tedious. further, i\u2019ve never seen any convincing evidence that they actually help. read the class definition, write some code, get over the scary name. you say you understand the maybe monad? good, you're on your way. just start using other monads and sooner or later you'll understand what monads are in general. [if you are mathematically oriented, you might want to ignore the dozens of tutorials and learn the definition, or follow lectures in category theory:) the main part of the definition is that a monad m involves a \"type constructor\" that defines for each existing type \"t\" a new type \"m t\", and some ways for going back and forth between \"regular\" types and \"m\" types.] also, surprisingly enough, one of the best introductions to monads is actually one of the early academic papers introducing monads, philip wadler's monads for functional programming. it actually has practical, non-trivial motivating examples, unlike many of the artificial tutorials out there.", "what? undefined (or code_removed) is really a value... it is the only value of type code_removed, for instance. since code_removed is strict, all values of type code_removed are therefore also code_removed.", "@groverboy i think there was a hint of sarcasm", "@christaylor while it's possible to answer this question without explaining monad, i really doubt if it will help the op in grasping the concept. that being said, there are lot of good answers down here.", "as of newer ghc versions, code_removed and similar functions are already generalised to use more general type signatures.", "@danburton fair. i did probably undersell code_removed. finger trees are one of the most awesome inventions in the history of computing (guibas should probably get a turing award someday) and code_removed is an excellent implementation and has a very useable api.", "there are lots of pragmatic questions, retrofitting dependent types to haskell. once we've got this restricted form of dependent function space, we still face the question of how to enlarge the fragment of the value language that's allowed at the type level, and what its equational theory should be (like we want 2+2 to be 4, and such). there are lots of fiddly issues (eg, bottom) that from-scratch dependently typed languages design away from the get go.", "i'm not talking about hamlet. the web-routes package was originally written for happstack which has essentially the same routing interface that snap has. you'll probably need a little glue code, but that's pretty much always going to be the case.", "undefined? how rude! sadly, unsafecoerce (unsafecoerce () <*> undefined) is not (), so in real life, there are observations which violate the laws.", "are these backward steps collected and documented anywhere? it would be interesting to see what else was considered a back step and if there are better solutions to them as well.", "one application that is useful and took me some time to figure out from the very short description at learn you a haskell: since: code_removed and parenthesizing the right hand side of an expression containing an infix operator converts it to a prefix function, one can write code_removed analogous to code_removed. why would anyone do this? for lists of functions, for example. both: code_removed and: code_removed are shorter than code_removed or code_removed. obviously, the latter variants would be more readable for most people.", "is there any reason why you cannot just use the inferred type for code_removed, which is code_removed and does not involve ambiguous type variables?", "let's start with a code example: code_removed this code doesn't compile (syntax error) in plain haskell 98. it requires an extension to support the code_removed keyword. basically, there are 3 different common uses for the code_removed keyword (or at least so it seems), and each has its own haskell extension: code_removed, code_removed/code_removed, code_removed. the code above doesn't get a syntax error with either of those enabled, but only type-checks with code_removed enabled. scoped type variables: scoped type variables helps one specify types for code inside code_removed clauses. it makes the code_removed in code_removed the same one as the code_removed in code_removed. a confusing point: you may hear that when you omit the code_removed from a type it is actually still implicitly there. (from norman's answer: \"normally these languages omit the forall from polymorphic types\"). this claim is correct, but it refers to the other uses of code_removed, and not to the code_removed use. rank-n-types: let's start with that code_removed is equivalent to code_removed, except for when code_removed is enabled. this means that it works for every code_removed and code_removed. let's say you want to do something like this. code_removed what's must be the type of this code_removed? it's code_removed. to see why, let's try to code it: code_removed \"hmm.. why does ghc infer that the tuple must contain two of the same type? let's tell it they don't have to be\" code_removed hmm. so here ghc doesn't let us apply code_removed on code_removed because code_removed and code_removed wants an code_removed. we really want our function to get a function that accepts any possible code_removed! code_removed so it's not code_removed that works for all code_removed, it's the function that it gets that does. existential quantification: let's use an example: code_removed how is that different from rank-n-types? code_removed with rank-n-types, code_removed meant that your expression must fit all possible code_removeds. for example: code_removed an empty list does work as a list of any type. so with existential-quantification, code_removeds in code_removed definitions mean that, the value contained can be of any suitable type, not that it must be of all suitable types.", "yesod also has an as-yet-unreleased interface to mongodb for persistent.", "haskell is a general purpose programming language. it can be used for anything you use any other language to do. you aren't limited by anything but your own imagination. as for what it's suited for? well, pretty much everything. there are few tasks in which a functional language does not excel. and yes, i'm the rayne from dreamincode.:) i would also like to mention that, in case you haven't read the wikipedia page, functional programming is a paradigm like object oriented programming is a paradigm. just in case you didn't know. haskell is also functional in the sense that it works; it works quite well at that. just because a language isn't an object oriented language doesn't mean the language is limited by anything. haskell is a general-purpose programming language, and is just as general purpose as java.", "welcome to so! nice to see you over here. you're over 100 rep now, so most of the really irritating limitations should be gone.:]", "@ruakh: that is exactly my point: if a programmer knows that a specific program is correct, even though its correctness cannot by proven by a given system (the haskell type system), then you might use code_removed. a treatment of what \"safe\" means is beyond the scope of this answer, if you would like to know more about the foundations of type safety, feel free to ask a question.", "first, the extensions and libraries that we're going to use: code_removed of these, code_removed is the only one that's absolutely essential to the below. i once wrote an explanation of code_removed that some people seem to have found useful, so i'll refer to that. quoting tom crockett's excellent answer, we have: a monad is... an endofunctor, t: x -> x a natural transformation, \u03bc: t \u00d7 t -> t, where \u00d7 means functor composition a natural transformation, \u03b7: i -> t, where i is the identity endofunctor on x ...satisfying these laws: \u03bc(\u03bc(t \u00d7 t) \u00d7 t)) = \u03bc(t \u00d7 \u03bc(t \u00d7 t)) \u03bc(\u03b7(t)) = t = \u03bc(t(\u03b7)) how do we translate this to haskell code? well, let's start with the notion of a natural transformation: code_removed a type of the form code_removed is analogous to a function type, but instead of thinking of it as a function between two types (of kind code_removed), think of it as a morphism between two functors (each of kind code_removed). examples: code_removed basically, in haskell, natural transformations are functions from some type code_removed to another type code_removed such that the code_removed type variable is \"inaccessible\" to the caller. so for example, code_removed cannot be made into a natural transformation, because it's \"picky\" about which types we may instantiate for code_removed. one intuitive way i often use to think of this is the following: a functor is a way of operating on the content of something without touching the structure. a natural transformation is a way of operating on the structure of something without touching or looking at the content. now, with that out of the way, let's tackle the clauses of the definition. the first clause is \"an endofunctor, t: x -> x.\" well, every code_removed in haskell is an endofunctor in what people call \"the hask category,\" whose objects are haskell types (of kind code_removed) and whose morphisms are haskell functions. this sounds like a complicated statement, but it's actually a very trivial one. all it means is that that a code_removed gives you the means of constructing a type code_removed for any code_removed and a function code_removed out of any code_removed, and that these obey the functor laws. second clause: the code_removed functor in haskell (which comes with the platform, so you can just import it) is defined this way: code_removed so the natural transformation \u03b7: i -> t from tom crockett's definition can be written this way for any code_removed instance code_removed: code_removed third clause: the composition of two functors in haskell can be defined this way (which also comes with the platform): code_removed so the natural transformation \u03bc: t \u00d7 t -> t from tom crockett's definition can be written like this: code_removed the statement that this is a monoid in the category of endofunctors then means that code_removed (partially applied to just its first two parameters) is associative, and that code_removed is its identity element. i.e., that the following isomorphisms hold: code_removed code_removed code_removed these are very easy to prove because code_removed and code_removed are both defined as code_removed, and the haskell reports define the semantics of code_removed as an isomorphism between the type being defined and the type of the argument to the code_removed's data constructor. so for example, let's prove code_removed: code_removed", "in this case there is a choice, but an example where you want a proxy is code_removed. the alternative would be to use the old way of doing it, code_removed. but that latter is unpleasant because you often have to use it with code_removed, and imho it's better to use code_removed.", "i would like to broaden my knowledge of programming. (...) i thought i would pose the question here, along with several stipulations about the type of language i am looking for. some are subjective, some are intended to ease the transition from haskell. strong type system. (...) it also makes informally reasoning about the correctness of my program easier. i'm concerned with correctness, not efficiency. emphasis on recursion rather than iteration. (...) you may be easing the transition a bit too much here, i'm afraid. the very strict type system and purely functional style are characteristic of haskell and pretty much anything resembling a mainstream programming language will require compromising at least somewhat on one of these. so, with that in mind, here are a few broad suggestions aimed at retaining most of what you seem to like about haskell, but with some major shift. disregard practicality and go for \"more haskell than haskell\": haskell's type system is full of holes, due to nontermination and other messy compromises. clean up the mess and add more powerful features and you get languages like coq and agda, where a function's type contains a proof of its correctness (you can even read the function arrow code_removed as logical implication!). these languages have been used for mathematical proofs and for programs with extremely high correctness requirements. coq is probably the most prominent language of the style, but agda has a more haskell-y feel (as well as being written in haskell itself). disregard types, add more magic: if haskell is sorcery, lisp is the raw, primal magic of creation. lisp-family languages (also including scheme and clojure) have nearly unparalleled flexibility combined with extreme minimalism. the languages have essentially no syntax, writing code directly in the form of a tree data structure; metaprogramming in a lisp is easier than non-meta programming in some languages. compromise a bit and move closer to the mainstream: haskell falls into the broad family of languages influenced heavily by ml, any of which you could probably shift to without too much difficulty. haskell is one of the strictest when it comes to correctness guarantees from types and use of functional style, where others are often either hybrid styles and/or make pragmatic compromises for various reasons. if you want some exposure to oop and access to lots of mainstream technology platforms, either scala on the jvm or f# on.net have a lot in common with haskell while providing easy interoperability with the java and.net platforms. f# is supported directly by microsoft, but has some annoying limitations compared to haskell and portability issues on non-windows platforms. scala has direct counterparts to more of haskell's type system and java's cross-platform potential, but has a more heavyweight syntax and lacks the powerful first-party support that f# enjoys. most of those recommendations are also mentioned in other answers, but hopefully my rationale for them offers some enlightenment.", "@tahirhassan - in the generality of category theory, we deal with opaque \"objects\" instead of sets, and so there is no a priori notion of \"elements\". but if you think about the category set where the objects are sets and the arrows are functions, the elements of any set s are in one-to-one correspondence with the functions from any one-element set to s. that is, for any element e of s, there is exactly one function f: 1 -> s, where 1 is any one-element set... (cont'd)", "@dietrich epp: that type doesn't make sense. code_removed is a value, not a type, and in fact i don't believe there's even anything that says code_removed values of different types can be compared, even conceptually. i doubt it even makes sense to consider equality of code_removeds of the same type, so i'm not sure that satisfying type class laws is even a well-formed question in the first place without introducing something that lets you compare code_removed values somehow.", "i'm sure you meant to say something really deep here", "if anyone else is interested in this application of polycategories to sequent calculi benton, bierman, paiva and hyland. linear lambda-calculus and categorical models revisited. is much shorter. for @c.a.mccann: this one covers the mell fragment.", "@coolhibou in category theory every object has an identity morphism (morphisms need not be functions). it's still true that haskell has the number 5, which is not a function: it's type is, say, int, not of the form a->b. there is, of course, id: int -> int but i trust you understand that this id function is different from the number 5.", "i really like explanation in terms of \"constraint-directed inference\". however, your solution doesn't get you that: the whole point in that situation is that you don't know which constraints are satisfied for your polymorphic type, so you can't possibly wrap it in the correct code_removed to get the instance you want.", "i have data types defined as: code_removed now, as it stands, i have a persistent model defined as: code_removed i can pretty easily create a query to populate a committeeview, using esqueleto. it would go something like this: code_removed now, consider the problem of populating code_removed. in principle, we get enough data to populate by running subquery in the above query. okay, fair enough. now how can i use \"group by haskell-list\" like code_removed in sql? how can i fold rows so that i can end up with a list of lists of people? i get the impression that code_removed can't handle the case as such (i.e., it doesn't have a combinator that would do it). and my underlying database obviously doesn't support haskell lists as a column. but, surely, i can't be the only person to face this issue. what is an effective strategy? folding an n-list of lists into a n-list? or running code_removed queries? are there any other options?", "should we avoid do-notation in any case? i'd say definitely no. for me, the most important criterion in such cases is to make the code as much readable and understandable as possible. the code_removed-notation was introduced to make monadic code more understandable, and this is what matters. sure, in many cases, using code_removed point-free notation is very nice, for example, instead of code_removed we'd write just code_removed. but there are many examples where not using the code_removed-notation will make code very unreadable. consider this example: code_removed here it's quite clear what's happening and how the code_removed actions are sequenced. a code_removed-free notation looks like code_removed or like code_removed which are both much less readable. certainly, here the code_removed-notation is much more preferable here. if you want to avoid using code_removed, try structuring your code into many small functions. this is a good habit anyway, and you can reduce your code_removed block to contain only 2-3 lines, which can be then replaced nicely by code_removed, code_removed<*>` etc. for example, the above could be rewritten as code_removed it's a bit longer, and maybe a bit less understandable to haskell beginners (due to code_removed, code_removed and code_removed), but in many cases those new, small functions can be reused in other places of your code, which will make it more structured and composable. i'd say the situation is very similar to whether to use the point-free notation or not. in many many cases (like in the top-most example code_removed) the point-free notation is great, but if you try to convert a complicated expression, you will get results like code_removed it'd take me quite a long time to understand it without running the code. [spoiler below:] code_removed also, why do most tutorials teach io with do? because code_removed is exactly designed to mimic imperative computations with side-effects, and so sequencing them using code_removed is very natural.", "+1 for considering broader concerns. although speaking as someone who went from c# to haskell, i agree with camccann that f# would be much nicer.", "thank you for spelling it out. i can understand what the other answers were trying to say now. i needed that extra explanation, that all nf are whnf but not all whnf. it makes senses because nf is the outermost and only expression.", "haskell has type inference. there is no need to state the type of code_removed and code_removed explicitly.", "function application (like code_removed) binds tighter than any operators, so your code is equivalent to: code_removed", "i'm not sure if i agree with the dynamic memory allocation part of this answer. just because the program doesn't know when a user will stop looping temporally shouldn't make it dynamic. that is determined by whether the compiler knows if something will go out of context. in haskell's case, where that is formally defined by the language grammar itself, the life context is known. however, the memory may still be dynamic for the reason that the list expressions and type are dynamically generated within the language.", "@bakuriu: done.", "it is merely a good programming practice. since record fields labels in haskell are actually top level named functions, they pollute the module namespace. adding an underscore to the field label means that you are free to define another function with the same name.", "it's actually just a normal type constructor that happens to be defined in the prelude, which is the standard library that is imported automatically into every module. what maybe is, structurally the definition looks something like this: code_removed that declaration defines a type, code_removed, which is parameterized by a type variable code_removed, which just means that you can use it with any type in place of code_removed. constructing and destructing the type has two constructors, code_removed and code_removed. when a type has multiple constructors, it means that a value of the type must have been constructed with just one of the possible constructors. for this type, a value was either constructed via code_removed or code_removed, there are no other (non-error) possibilities. since code_removed has no parameter type, when it's used as a constructor it names a constant value that is a member of type code_removed for all types code_removed. but the code_removed constructor does have a type parameter, which means that when used as a constructor it acts like a function from type code_removed to code_removed, i.e. it has the type code_removed so, the constructors of a type build a value of that type; the other side of things is when you would like to use that value, and that is where pattern matching comes in to play. unlike functions, constructors can be used in pattern binding expressions, and this is the way in which you can do case analysis of values that belong to types with more than one constructor. in order to use a code_removed value in a pattern match, you need to provide a pattern for each constructor, like so: code_removed in that case expression, the first pattern would match if the value was code_removed, and the second would match if the value was constructed with code_removed. if the second one matches, it also binds the name code_removed to the parameter that was passed to the code_removed constructor when the value you're matching against was constructed. what maybe means maybe you were already familiar with how this worked; there's not really any magic to code_removed values, it's just a normal haskell algebraic data type (adt). but it's used quite a bit because it effectively \"lifts\" or extends a type, such as code_removed from your example, into a new context in which it has an extra value (code_removed) that represents a lack of value! the type system then requires that you check for that extra value before it will let you get at the code_removed that might be there. this prevents a remarkable number of bugs. many languages today handle this sort of \"no-value\" value via null references. tony hoare, an eminent computer scientist (he invented quicksort and is a turing award winner), owns up to this as his \"billion dollar mistake\". the maybe type is not the only way to fix this, but it has proven to be an effective way to do it. maybe as a functor the idea of transforming one type to another one such that operations on the old type can also be transformed to work on the new type is the concept behind the haskell type class called code_removed, which code_removed has a useful instance of. code_removed provides a method called code_removed, which maps functions that range over values from the base type (such as code_removed) to functions that range over values from the lifted type (such as code_removed). a function transformed with code_removed to work on a code_removed value works like this: code_removed so if you have a code_removed value code_removed and an code_removed function code_removed, you can do code_removed to apply the function code_removed directly to the code_removed without worrying if it's actually got a value or not. in fact, you could apply a whole chain of lifted code_removed functions to code_removed values and only have to worry about explicitly checking for code_removed once when you're finished. maybe as a monad i'm not sure how familiar you are with the concept of a code_removed yet, but you have at least used code_removed before, and the type signature code_removed looks remarkably similar to code_removed. although code_removed is special in that it doesn't expose its constructors to you and can thus only be \"run\" by the haskell runtime system, it's still also a code_removed in addition to being a code_removed. in fact, there's an important sense in which a code_removed is just a special kind of code_removed with some extra features, but this isn't the place to get into that. anyway, monads like code_removed map types to new types that represent \"computations that result in values\" and you can lift functions into code_removed types via a very code_removed-like function called code_removed that turns a regular function into a \"computation that results in the value obtained by evaluating the function.\" you have probably guessed (if you have read this far) that code_removed is also a code_removed. it represents \"computations that could fail to return a value\". just like with the code_removed example, this lets you do a whole bunch of computations without having to explicitly check for errors after each step. and in fact, the way the code_removed instance is constructed, a computation on code_removed values stops as soon as a code_removed is encountered, so it's kind of like an immediate abort or a valueless return in the middle of a computation. you could have written maybe like i said before, there is nothing inherent to the code_removed type that is baked into the language syntax or runtime system. if haskell didn't provide it by default, you could provide all of its functionality yourself! in fact, you could write it again yourself anyway, with different names, and get the same functionality. hopefully you understand the code_removed type and its constructors now, but if there is still anything unclear, let me know!", "see meta.stackexchange.com/questions/56669/\u2026, meta.stackexchange.com/questions/57226/\u2026, and related meta posts", "haskell has special syntax for lists because in a lazy functional language they more or less take the place of loop control structures in imperative languages. so they're much more important than code_removed in the grand scheme. also, i know you were referring to code_removed when you said \"list syntax\", but i wanted to add that list constructor syntax could almost be implemented in haskell-98, in that type constructors can be infix when they start with code_removed, e.g. code_removed so the list constructor code_removed is just a slight special case of this general syntax rule, which is pretty elegant. some people miss that.", "it's true. i tried to make it clear what was being talked about despite. perhaps i'll edit to inline illisuis's points.", "function execution time benchmark is included in criterion.measurement for example, if i want to capture the time of code_removed code_removed", "if you change code_removed to be small does it still yield a segmentation fault?", "it sort of has one in that you can write code_removed to get a map that sends code_removed to code_removed and code_removed to code_removed. i know that this isn't actually a literal, but it's pretty close. it is a constant applicative form, so the function call can be optimized away by the compiler.", "do you have a self contained example (imports included) that generates output like the above? i think i have an idea what the problem might be, but it is a bit hard to tell only from the output...", "tested with deepseq's code_removed: code_removed = code_removed", "@unsymbol do you have an answer for you question? please consider adding it here:)", "possible duplicate of does haskell have list slices (i.e. python)?", "why is it that when i do range in haskell, this works: code_removed but this doesn't: code_removed and what does this cryptic error mean: code_removed however, when i use ints, the second form (without spaces) works: code_removed", "i am having problem in entering multi-line commands in ghci. the following 2-line code works from a file: code_removed but when i enter in ghci, i get errors. i also tried putting the code inside code_removed, but they are also not working for this example, because this is just appending the lines into one line, which should not be the case. i am using winghci, version 2011.2.0.1", "its a good question, and i'm not aware of any answers. perhaps we need a naming scheme, or perhaps library authors should provide pronounceable names as part of haddock docs.", "template haskell code sometimes looks for identifiers beginning with an underscore. for instance, underscores are used to automate lens generation.", "a footnote to the conversation, for posterity: @augustss using ad-hoc polymorphism to make code_removeds implicit, or at least attempting to and being thwarted by changes to ghc.:[", "i've created the tickect (#9699). what i mean by the second point is that a function might declare a variable called code_removed, and then the code_removed from code_removed would no longer be in scope. so the result of code_removed has a pretty complicated dependence on where in the code the splice occurs.", "@sclv my work hasn't especially targeted the \"no phase distinction\" myth, but others' has. i recommend the rejectum \"phase distinctions in the compilation of epigram\", by james mckinna and edwin brady, as a good place to start. but see also much older work on program extraction in coq. the open-terms evaluation done by the typechecker is completely separate from execution via extraction to ml, and it is clear that extraction strips out types and proofs.", "the billion dollar mistake link seems to be broken now:(", "most people request overlapping instances because they want constraint-directed inference instead of type-directed inference. type classes were made for type-directed inference and haskell does not provide an elegant solution to constraint-directed inference. however, you can still \"encapsulate the goodness\" by using newtypes. given the following instance definition which is prone to overlapping instances: code_removed you can instead use: code_removed now haskell's type-class system has a proper specific type to match on (i.e. code_removed), instead of matching gratuitously on every single type. this lets you control the scope of the instance since only things wrapped in the code_removed newtype will now match.", "sure. you can have a look at a real example here but in general, code_removed is usable on any pure function that happens to be side effecting. the code_removed monad may still be needed to track effects (e.g. freeing memory after the value is computed) even when the function is pure (e.g computing a factorial). i'm wondering what c functions i can use unsafeperformio with. i assume using unsafeperformio with anything involving pointers is a big no-no. depends! code_removed will fully perform actions and force out all the laziness, but that doesn't mean it will break your program. in general, haskellers prefer code_removed to appear only in pure functions, so you can use it on results of e.g. scientific computations but maybe not file reads.", "@russel: thanks for pointing out the most probable origin (being spj himself as it seems) of that saying!", "@akshay2000 sorry, i can't be held accountable for your feelings. if you have an objective reason to dislike this solution, i'd be happy to discuss it, potential mitigations, and their tradeoffs.", "another odd thing is that if i ask ghci code_removed, it tells me code_removed, but if i ask code_removed, it tells me code_removed. so something seems to be very strange about how the parser handles code_removed.", "thank you very much for the effort. very nice answer.:)", "in the years since this answer was written, this sentence seems to have become less true: \"higher-rank types (forall to the left of an arrow) are rarely found in the wild.\" the trick code_removed uses to prevent unsafe usage is now reasonably common: see code_removed in code_removed, for example.", "from the documentation: computationally, there is no reason to use the identity monad instead of the much simpler act of simply applying functions to their arguments. the purpose of the identity monad is its fundamental role in the theory of monad transformers. any monad transformer applied to the identity monad yields a non-transformer version of that monad. as i understand it, getting the non-transformer version of a monad from a monad transformer by applying the identity monad is exactly the thing that the identity monad is there for. there is no advantage over just using the non-transformer monad, yet sometimes you have to use a monad transformer, e.g. when a function you want to use requires it.", "@user76284 this is highly subjective, but i would dislike the lack of uniformity in how some types are deemed worthy of instances and others not, when they could have them just as well. someone somewhere might need them, why force an orphan instance upon him? less subjectively, the more instances a type has the more code you can potentially get \"for free\" when composing types. the composition of two foldable functors is foldable for example. opting out by defining your own tuple-like type is relatively easy as well, i often do it for folds with complex accumulators to make code more legible.", "notice that code_removed replaces your if-then-else.", "@yitz - real world computers use strict evaluation. compilers don't need to work hard to evaluate strictly - they need to work hard (adding thunks, deferring evaluation, strictness analysis to determine where that's not necessary) to support laziness. it took ghcs authors a very long time to control those overheads and, despite that, a strict language is more referentially transparent than a lazy version of the same language - laziness means that time and space complexity aren't referentially transparent due to deferred computations and the mutable data structure used to keep track of them.", "the only thing you can observe from the player class is a function of type code_removed hence, you can eliminate the class entirely and use an ordinary data type code_removed this is basically my previous answer. an alternative solution is to move the context into the data type by using gadts. code_removed in other words, the constraints become part of the data type. the best solution is, in my opinion, to scrap the whole thing and redesign it along the lines of the tictactoe example from my operational package. this design allows you to write each player (human, ai, replay,...) in a specialized monad and later inject everything into a common interpreter.", "possible duplicate? stackoverflow.com/questions/1604790/\u2026", "i've been learning haskell from learn you a haskell and just came across the following statement: doing code_removed results in a non-deterministic computation code_removed where code_removed takes on every value from code_removed and code_removed takes on every value from code_removed. i don't think i understand what is non-deterministic about this. is it just that the order of the results or the order of computation is not guaranteed to be the same every time?", "i appreciate your answer\u2014especially the final concession that all of this is of course possible too without monads. one point to be made is that it's mostly easier with monads, but it's often not as efficient as doing it without them. once you need to involve transformers, the extra layering of function calls (and function objects created) has a cost that's hard to see and control, rendered invisible by clever syntax.", "sequencing isn't the only reason to define a monad. a monad is just any functor which has bind and return. bind and return give you sequencing. but they give other things as well. also, note that your favorite imperative language is effectively a fancy io monad with oo classes. making it easy to define monads means it's easy to use the interpreter pattern -- define a dsl as a monad and interpret it!", "@greg, hmm, interesting. can you speculate why they exist?", "c.a.mcc: i don't know what you mean by \"specific instances may not have intrinsically imperative structure, but monad in general really does.\" (does in general but not in particular??) nor what collapsing functor nesting has to do with imperative computation. maybe \"imperative\" has a meaning for you that i wouldn't expect.", "you can change directory via code_removed load another file/module. it causes the preceding module to unload. see the definition of:cd/:load in", "in a code_removed declaration, a type constructor is the thing on the left hand side of the equals sign. the data constructor(s) are the things on the right hand side of the equals sign. you use type constructors where a type is expected, and you use data constructors where a value is expected. data constructors to make things simple, we can start with an example of a type that represents a colour. code_removed here, we have three data constructors. code_removed is a type, and code_removed is a constructor that contains a value of type code_removed. similarly, code_removed and code_removed are both constructors that construct values of type code_removed. we could imagine spicing it up though! code_removed we still have just the type code_removed, but code_removed is not a value \u2013 it's a function taking three ints and returning a value! code_removed has the type code_removed code_removed is a data constructor that is a function taking some values as its arguments, and then uses those to construct a new value. if you have done any object-oriented programming, you should recognise this. in oop, constructors also take some values as arguments and return a new value! in this case, if we apply code_removed to three values, we get a colour value! code_removed we have constructed a value of type code_removed by applying the data constructor. a data constructor either contains a value like a variable would, or takes other values as its argument and creates a new value. if you have done previous programming, this concept shouldn't be very strange to you. intermission if you'd want to construct a binary tree to store code_removeds, you could imagine doing something like code_removed what we see here is a type code_removed that contains two data constructors. in other words, there are two functions (namely code_removed and code_removed) that will construct values of the code_removed type. if you're not familiar with how binary trees work, just hang in there. you don't actually need to know how binary trees work, only that this one stores code_removeds in some way. we also see that both data constructors take a code_removed argument \u2013 this is the string they are going to store in the tree. but! what if we also wanted to be able to store code_removed, we'd have to create a new binary tree. it could look something like this: code_removed type constructors both code_removed and code_removed are type constructors. but there's a glaring problem. do you see how similar they are? that's a sign that you really want a parameter somewhere. so we can do this: code_removed now we introduce a type variable code_removed as a parameter to the type constructor. in this declaration, code_removed has become a function. it takes a type as its argument and it returns a new type. it is important here to consider the difference between a concrete type (examples include code_removed, code_removed and code_removed) which is a type that can be assigned to a value in your program, and a type constructor function which you need to feed a type to be able to be assigned to a value. a value can never be of type \"list\", because it needs to be a \"list of something\". in the same spirit, a value can never be of type \"binary tree\", because it needs to be a \"binary tree storing something\". if we pass in, say, code_removed as an argument to code_removed, it returns the type code_removed, which is a binary tree that stores code_removeds. replace every occurrence of the type variable code_removed with the type code_removed, and you can see for yourself how it's true. if you want to, you can view code_removed as a function with the kind code_removed kinds are somewhat like types \u2013 the code_removed indicates a concrete type, so we say code_removed is from a concrete type to a concrete type. wrapping up step back here a moment and take note of the similarities. a data constructor is a \"function\" that takes 0 or more values and gives you back a new value. a type constructor is a \"function\" that takes 0 or more types and gives you back a new type. data constructors with parameters are cool if we want slight variations in our values \u2013 we put those variations in parameters and let the guy who creates the value decide what arguments they are going to put in. in the same sense, type constructors with parameters are cool if we want slight variations in our types! we put those variations as parameters and let the guy who creates the type decide what arguments they are going to put in. a case study as the home stretch here, we can consider the code_removed type. its definition is code_removed here, code_removed is a type constructor that returns a concrete type. code_removed is a data constructor that returns a value. code_removed is a data constructor that contains a value. if we look at the type of code_removed, we see that code_removed in other words, code_removed takes a value of type code_removed and returns a value of type code_removed. if we look at the kind of code_removed, we see that code_removed in other words, code_removed takes a concrete type and returns a concrete type. once again! the difference between a concrete type and a type constructor function. you cannot create a list of code_removeds - if you try to execute code_removed you'll get an error. you can however create a list of code_removed, or code_removed. that's because code_removed is a type constructor function, but a list needs to contain values of a concrete type. code_removed and code_removed are concrete types (or if you want, calls to type constructor functions that return concrete types.)", "with functors and coproducts you can just view this as an \"hlist1\". it's just the usual trick of having a type level representation of the value level list. it can be made a lot prettier with gadts + datakinds to promote a proper list to type level", "an example based on chuck's answer: code_removed note that without the code_removed the third line will not compile.", "chuck is right, function application in haskell is left associative, meaning that a function invocation like code_removed is equivalent to code_removed. remember, in haskell you should always practice looking at types of functions and trying to infer what a function can and can't do based on its type. at first you might fail to deduce anything from a function type, but with more experience type information will become indispensable. what is the type of code_removed? enter code_removed in ghci. it will return code_removed. code_removed and code_removed are type variables, meaning that const will accept an argument of any type. as 1st and 2nd arguments have different types, you can pass practically everything to the function: code_removed there might've been specific typeclass constraints on type variables of code_removed that would prevent passing functions, like code_removed or code_removed, because a function isn't an instance of these typeclasses. in other words, a function doesn't behave as a number or an ordered thing, so code_removed or code_removed don't make sense. but code_removed has no typeclass constraints that would stop us from passing functions as arguments. remember that haskell supports higher-order functions? this means that haskell's functions can accept and return other functions. therefore: code_removed code_removed just ignores the 2nd argument and returns whatever was passed as a 1st argument, be it a char, string, integer, maybe, [], some very complex algebraic data type, or even a function. if the type of code_removed is code_removed, can you guess the type of code_removed without finding it out without typing code_removed in ghci? to find out a type of code_removed, substitute the type of the 1st argument in place of all same type variables, then remove the first argument from the type. code_removed: original type code_removed: substitute new type in type variables a code_removed: the type of a new function by removing the 1st argument from type declaration what is the type of code_removed then? code_removed: original type code_removed: substitution code_removed: resulting type (first argument removed) code_removed: same as above, code_removed operator is right-associative exercise: try to figure out mentally or with pen and paper, without using ghci, what are the types of: code_removed, code_removed, code_removed, code_removed, code_removed try to find out what arguments would you pass to the above functions to get a concrete value.", "\"monads can be seen as monoids in the category of endo functors\" <3 (you should link to stackoverflow.com/a/3870310/1306877 because every haskeller should know about that reference!)", "as larsmans said it is up to the compiler, to decide what to do. but i would expect ghc to populate the list up till the 201st element. but it would not evaluate those elements. assuming there is a factorial function: code_removed the following code will print the factorial of 200, it will create the first 201 cells of the list, but it will evaluate only one factorial. code_removed", "looks like a homework or something. better to add your approach and ask the community for ways to improve it instead of just asking the answer.", "will not be necessary with upcoming ghc releases (probably 7.8): hackage.haskell.org/trac/ghc/ticket/6063#comment:19", "you would be better off removing the file and simply recovering if it does not exist: code_removed this avoids the race condition of someone deleting the file between your code checking whether it exists and deletes it. it might not matter in your case, but it's good practice anyway. note the code_removed line \u2014 this is because the prelude contains older functions from exception handling which are now deprecated in favour of control.exception, which also has a function named code_removed; the import line simply hides the prelude's code_removed in favour of control.exception's. however, that still leaves your more fundamental underlying question: how do you write conditionals in code_removed? well, in this case, it would suffice to simply do code_removed (using control.monad.when). but it's helpful here, as it usually is in haskell, to look at the types. both branches of a conditional must have the same type. so to fill in code_removed we should look at the type of code_removed; whatever code_removed is, it has to have the same type. system.directory.removefile has the type code_removed, so code_removed has the type code_removed. so what we want is an io action with a result of type code_removed that does nothing. well, the purpose of code_removed is to construct an action that has no effects, and just returns a constant value, and code_removed has the right type for this: code_removed (or more generally, code_removed). so code_removed is code_removed (which you can see i used in my improved snippet above, to do nothing when code_removed fails because the file doesn't exist). (by the way, you should now be able to implement code_removed with the help of code_removed; it's really simple:)) don't worry if you find it hard to get into the haskell way of things at first \u2014 it'll come naturally in time, and when it does, it's very rewarding.:)", "it's been 6 years since this question was asked and since the go programming language debuted. despite having a weaker type system and generally being \"objectively inferior\" (according to functional/ml fans), it's managed to ship more (and more important) software in those 6 years than haskell has in its 26 years. i mean this as a case study; there are clearly things that are holding functional languages back, and they can't all be attributed to hype.", "@nawaz: that's the point of being able to compose \"action\"s. you can, in principle, translate any imperative program into monadic haskell code. the difference is that haskell's type checker enforces the separation of io operations from purely functional code.", "is there a general pattern to when code_removed is actually the best choice? (like infinite lists when code_removed is the wrong choice, optimization-wise.?)", "have you looked at code_removed?", "@semicolon code_removed actually shares some of the same problems as code_removed; however, for some reason, extant libraries have mostly managed to avoid the temptation to do weird things in code_removed. i admit i have no technical explanation for this outcome. for your second question, you may like to read what is the monomorphism restriction?.", "the third example is basically my question, why doesn't it work?", "@egdmitry: yes. the point is that in order to get there, it first has to evaluate all the recursive calls to code_removed before it can do the sums, generating a lot of unnecessary thunks in the process.", "i know you were just drawing an analogy rather than making a definition, but a free monad is certainly not analogous to a list of functors in any sense. it's much closer to a tree of functors.", "\"functional guis\" link broken:( cached: webcache.googleusercontent.com/search?q=cache:", "ghc is probably the biggest or one of the biggest projects written in haskell that is open source. when i say biggest, i do not just mean in terms of source size, but also impact, use, innovation, robustness. ghc can teach you a lot about writing haskell.", "typeclasses like code_removed, code_removed, code_removed, code_removed are great and all, and even more great for changing how you think about code than necessarily the convenience of having functions generic over them. but there's a common misconception that the \"next step\" in haskell is learning about more typeclasses and ways of structuring control flow. the next step is in deciding what you want to write, and trying to write it, exploring what you need along the way. and even if you understand monads, that doesn't mean you've scratched the surface of what you can do with monadically structured code. play with parser combinator libraries, or write your own. explore why applicative notation is sometimes easier for them. explore why limiting yourself to applicative parsers might be more efficient. look at logic or math problems and explore ways of implementing backtracking -- depth-first, breadth-first, etc. explore the difference between listt and logict and choicet. take a look at continuations. or do something completely different!", "i'd like to add this excellent blog post here too: stephendiehl.com/posts/monads.html it doesn't directly answer the question, but in my opinion stephen does a superb job of tying categories and monads in haskell together. if you've read the above answers - this should help unify the two ways of looking at this.", "@christianconkle i looked at the code_removed bit and at the moment i understood what that was good for, i agreed that that's a \"hack job\";) (just using any code_removed kind to \"wrap\" the inner type somehow, because we don't actually care what the wrapper is. so actually that type variable bit in itself is ok, because well we don't care, but instantiating the wrapper to list, or any other concrete type, really makes it awkward.)", "please upgrade your ghc installation. ghc 6.6 is nearly 5 years old! the latest versions of haskell are here: haskell.org/platform", "note that a one-tuple would have a different behavior with regard to bottoms: just as code_removed is not the same as code_removed, so too would code_removed be different from code_removed. i can't imagine them being useful, mind you, but it's worth noting. (and python's syntax would clash with the useful code_removed.)", "i could, of course, add more instances, e.g. d [] = []:*: [], which would ensure that repeated differentiation would not always result in something isomorphic to k void. for composition, add d (f:.: g) = (d f:.: g):*: d g. for free monads add d (free f) = ([]:.: d f:.: (free f)). we can certainly stay smooth without needing to be nilpotent.", "there is demonstrating code_removed code running.", "interesting, but that code_removed in the for loop isn't referentially transparent;)", "i find myself doing more and more scripting in haskell. but there are some cases where i'm really not sure of how to do it \"right\". e.g. copy a directory recursively (a la unix code_removed). since i mostly use linux and mac os i usually cheat: code_removed but what is the recommended way to copy a directory in a platform independent fashion? i didn't find anything suitable on hackage. this is my rather naiv implementation i use so far: code_removed any suggestions of what really is the way to do it? i updated this with the suggestions of hammar and fuzxxl....but still it feels kind of clumsy to me for such a common task!", "it's probably worth reminding that lifts should respect the standard laws code_removed and code_removed.", "very likely it's the linker itself. the standard code_removed from binutils is known to be slow. if you want to speed things up (and live a bit on the edge), try installing the gold linker. on ubuntu (and i assume debian), that would be: code_removed i've been using it on my home system for a while now, no issues yet.", "whenever possible, reuse library code. code_removed try it out in ghci: code_removed", "i found something likes a roadmap here in case all of you need: lambdaconf.us/downloads/documents/lambdaconf_slfp.pdf", "that code_removed instance itself is extremely obscure.", "seems that it has c-library dependencies? some double-conversion...", "@akshay2000 sorry, i can't be held accountable for your feelings. if you have an objective reason to dislike this solution, i'd be happy to discuss it, potential mitigations, and their tradeoffs.", "there is a key difference between java and haskell that you are missing. in java, the type information is not lost when upcasting, so you can downcast again and do other useful non-code_removedy things later (conditioned on choosing the right type to downcast to). in haskell, once you've upcast, the type information is lost and you cannot downcast again. so you might as well just have a list of code_removeds. see also code_removed, which offers a richer interface than \"just code_removed\".", "what is the difference when i write this? code_removed", "another way would be using code_removed since code_removed for lists is defined as code_removed", "i did wonder whether to ask on programmers or not. but: 1- the subject seems too technical compared to other questions. 2- no \"erlang\", \"haskell\" no \"node.js\" tags. 3- the answer \"could\" involve some code.", "a language that has recently come to my attention is eta. eta's compiler is a fork of ghc 7.10 which has a jvm backend. it is possible to use the generated jar files to write android apps and even use its foreign function interface to call native android java libraries. brian mckenna has written a blog post about how to configure an android studio project to use an eta library.", "also, does the compiled version target a particular architecture, or can it usually run on both os x and linux?", "super good answer! thanks!", "in the specific case of the ffi, code_removed is meant to be used for calling things that are mathematical functions, i.e. the output depends solely on the input parameters, and every time the function is called with the same inputs, it will return the same output. also, the function shouldn't have side effects, such as modifying data on disk, or mutating memory. most functions from code_removed could be called with code_removed, for example. you're correct that code_removed and pointers don't usually mix. for example, suppose you have code_removed even though you're just reading a value from a pointer, it's not safe to use code_removed. if you wrap code_removed, multiple calls can use the pointer argument, but get different results. it's necessary to keep the function in code_removed to ensure that it's sequenced properly in relation to pointer updates. this example should make clear one reason why this is unsafe: code_removed when compiled, this program outputs code_removed even though the value referenced by the pointer has changed between the two references to \"sin1\", the expression isn't re-evaluated, leading to stale data being used. since code_removed (and hence code_removed) is in io, the program is forced to re-evaluate the expression, so the updated pointer data is used instead.", "why i shouldn't do something simple and only defining functions without defining new data types and typeclasses (with their instances). why indeed? you could just define: code_removed people misuse type classes all the time. it doesn't mean that it's idiomatic. to answer your more general question, here are some rules of thumb for when to use type classes and when not to use them: use type classes if: there is only one correct behavior per given type the type class has associated equations (i.e. \"laws\") that all instances must satisfy don't use type classes if: you are trying to just namespace things. that's what modules and namespaces are for. a person using your type class cannot reason about how it will behave without looking at the source code of the instances you find that the extensions you have to turn on are getting out of control", "marked another answer as accepted because it contains a workaround that is usable right now. i would up vote you twice for your efforts if i could for pushing to make this happen. looking forward to getting this feature merged upstream. when that happens, i'll probably change the accepted answer accordingly -- since there will no longer be a need for a workaround.", "@viraptor it compiles to assembly?", "they are strong lax monoidal functors, to be precise!", "i'm assuming you correctly wrote code_removed rather than code_removed", "this answer is obsolete. see glguy's answer below. works in ghci 8.0.1.", "i'm facing a related situation right now designing a merge api for code_removed. the \"open\" approach is preferable in some ways. for one thing, i can implement it without gadts and therefore maintain compatibility with report haskell. for another, i don't need huge case analyses everywhere. but it's unpleasant in some other ways; in particular, it's much harder for me to take advantage of what i know about the behavior of values constructed in particular manners to optimize things.", "@tibbe i haven't yet learned that those are now available via code_removed, thanks. so what i had tried was code_removeduncheckedishiftl#` s)code_removedunsafeshiftlcode_removedshiftl` (but not the comparison against 0, seems ghc knows code_removed is never negative).", "@luqui i pronounce it compose if it appears as an argument to another function, eg. code_removed foldr-one compose list of f, g, i, j.", "@ kennytm a lot of people will find that link useful! a link alone is +1, but for showing how to use it... that's +10 thanks:)", "@passerby better than haskell's \"this expression will always evaluate to an integer unless it's code_removed or it uses code_removed functions or calls foreign code that breaks this or that rule\"?", "code_removed this takes the action \"code_removed\" and stores the action in code_removed. code_removed this executes the action \"code_removed\" and stores the result of the action in code_removed. in the first example, code_removed is an unexecuted i/o action object. in the second example, code_removed is the contents of a file on disk.", "simply consider every previous output of your 'time' function from this current run as part of the input to the function. thus it can never be called twice with the same inputs during the same run.", "@alexandrec. i'd disagree on that, it's not a good example. mathematically, such a data structure does form a functor. the fact that we cannot implement code_removed is just a language/implementation issue. also, it's possible to wrap code_removed into the continuation monad, which makes a monad out of it with all the properties we'd expect, see this question (although i'm not sure if it can be done efficiently).", "as ed kmett pointed out, this is not possible at all for your case. if however you have access to the class you want to provide a default instance for, you can reduce the boilerplate to a minimum with a default implementation and constrain the input type with the default signature you need: code_removed note that the only real boilerplate (well, apart from the whole example) reduced to code_removed. see code_removeds code_removed for a more realistic example.", "thank you for the info...i'm going to use data.map.", "exactly my thoughts!", "i'm not skilled enough to comb the source for the implementation, but that's what i suspect.", "basically, \"bottom\" is any undefined value like the result of calling error. something that loops forever is also called bottom.", "@antonyhatchkins in that case you'd need to change the first line to code_removed, since you're mixing the two together, and so they need to have the same type.", "doh! thanks for pointing that out! fixed. yes, undisciplined would probably be a better way of putting it. i think that the distinction here is really between \"built-in\", and therefore \"well understood\" abstraction mechanisms, versus \"ad-hoc\", or user-defined abstraction mechanisms. i suppose what i mean is that you could conceivably define a th library which implemented something quite similar to typeclass dispatch (albeit at compile time not runtime)", "sure, you could. for a real solution, though, i'd probably use a memoization library, like memocombinators", "oops, i read too fast, and only noticed the part about code_removed vs code_removed. thanks!", "elliot's talk on frp can be found here. in addition, not really an answer but a remark and a few thoughts: somehow the term \"functional gui\" seems a little bit like an oxymoron (pureness and io in the same term). but my vague understanding is that functional gui programming is about declaratively defining a time dependent function that takes the (real)time dependent user input and produces time dependent gui output. in other words, this function is defined like a differential equation declaratively, instead of by an algorithm imperatively using mutable state. so in conventional fp one uses time independent functions, while in frp one uses time dependent functions as building blocks for describing a program. let us think about simulating a ball on a spring with which the user can interact. the ball's position is the graphical output (on the screen), user pushing the ball is a keypress (input). describing this simulation program in frp (according to my understanding) is done by a single differential equation (declaratively): acceleration * mass = - stretch of spring * spring constant + force exerted by the user. here is a video on elm that illustrates this viewpoint.", "yes, those should be backticks. are there really people who consider this to be a hidden feature?", "thanks for posting the core. i might be a bit blind but except for identifier names the two piece of core generated look equal to me. so my first guess would be that you performd your timings without compiling with -o2, or there's some flakyness in your measurements (system load? differing input data? something else?).", "i said that in ghc it works. maybe in any other haskell compiler it is parsed as i said.", "@sarah: i'm yet to see a piece of documentation or irc conversation about haskell that is not heavy on computer theory and lambda calculus therms.", "c.a.mcc: i read \"do x, then do y, then...\" as your own interpretation/bias showing through, rather than anything actually in the nature of arbitrary monads. i wouldn't use these terms or this mindset for many of my favorite monads, e.g., code_removed, code_removed, code_removed, code_removed, code_removed, code_removed, and all trie types. bias aside, monadness is nothing more than two generic operations and their three laws. there is nothing intrinsically imperative there, and if there were, they wouldn't hold for the monads i mentioned (unless one is willing to argue that everything is imperative, even if trivially).", "@christianconkle yes, i could.", "this was helpful to me. however, what's the base case?", "why no stack overflow will occur if i do so? what's haskell's recursive different from c's", "excellent, that's exactly what i was looking for--looks much more interesting than the imperative approaches i've seen (for instance in real world haskell). i'll definitely be checking out various frp libraries.", "i thought of using pattern matching against the known possibilities.", "\"since haskell is lazy, your code will succeed if you do not use the resulting value\" -- it is worth mentioning it also matters that code_removed bindings match lazily by default. code_removed crashes, while code_removed (which, thanks to the lazy match, is equivalent to your third example) succeeds.", "why i shouldn't do something simple and only defining functions without defining new data types and typeclasses (with their instances). why indeed? you could just define: code_removed people misuse type classes all the time. it doesn't mean that it's idiomatic. to answer your more general question, here are some rules of thumb for when to use type classes and when not to use them: use type classes if: there is only one correct behavior per given type the type class has associated equations (i.e. \"laws\") that all instances must satisfy don't use type classes if: you are trying to just namespace things. that's what modules and namespaces are for. a person using your type class cannot reason about how it will behave without looking at the source code of the instances you find that the extensions you have to turn on are getting out of control", "i'm trying to figure out how to properly use the openssl.session api in a concurrent context e.g. assume i want to implement a code_removed, i'd expect to have the following basic skeleton structure, which implements a naive code_removed code_removed how do i transform the above skeleton into a code_removed? where are the dangers w.r.t to concurrent/parallel execution (in the context of the above use-case) of the function calls provided by the hsopenssl api? ps: i'm still struggling to fully comprehend how to make the code robust w.r.t. to exceptions and resource-leaks. so, albeit not being the primary focus of this question, if you notice something bad in the code above, please leave a comment.", "question 1: do erlang, python and haskell lose speed due to using arbitrary length integers or don't they as long as the values are less than maxint? question one can be answered in the negative for erlang. the last question is answered by using erlang appropriately, as in: since it's faster than your initial c example, i would guess there are numerous problems as others have already covered in detail. this erlang module executes on a cheap netbook in about 5 seconds... it uses the network threads model in erlang and, as such demonstrates how to take advantage of the event model. it could be distributed over many nodes. and it's fast. not my code. code_removed the test below took place on an: intel(r) atom(tm) cpu n270 @ 1.60ghz code_removed", "in addition to \"real world haskell\", find a copy of \"haskell: the craft of functional programming\". great textbook.", "functor coproducts don't have to be ugly/a lot of typing", "i have downloaded 10 slides from this page and going through it for many times. it workz;)", "@ganeshsittampalam here is my implementation. i don't seem to have a problem with maybe implementing ifunctor. works great in production.", "my answer is fundamentally the same as erikr's: the type that best embodies your requirements is code_removed. but i'll go a bit more into the logic that i believe justifies this answer. the key is in this quote from the question: [...] things which have one property in common, namely, they could be turned into string. let's call this type code_removed. but now the key observation is this: code_removed is isomorphic to code_removed! that is, if your statement above is the whole specification of the code_removed type, then there is a pair functions with these signatures: code_removed ...such that the two functions are inverses. when two types are isomorphic, any program that uses either of the types can be rewritten in terms of the other without any change to its semantics. so code_removed doesn't let you do anything that code_removed doesn't let you do already! in more concrete terms, the point is that this refactoring is guaranteed to work no matter what: at every point in your program where you turn an object into a code_removed and stick that into a code_removed, turn the object into a code_removed and stick that into a code_removed. at every point in your program that you consume a code_removed by applying code_removed to it, you can now eliminate the call to code_removed. note that this argument generalizes to types more complex than code_removed, with many \"methods\". so for example, the type of \"things that you can turn into either a code_removed or an code_removed\" is isomorphic to code_removed. the type of \"things that you can either turn into a code_removed or combine them with a code_removed to produce a code_removed\" is isomorphic to code_removed. and so on. basically, this logic leads to the \"record of methods\" encoding that other answers have brought up. i think the lesson to draw from this is the following: you need a specification richer than just \"can be turned into a string\" in order to justify using any of the mechanisms you brought up. so for example, if we add the requirement that code_removed values can be downcast to the original type, an existential type now perhaps becomes justifiable: code_removed this code_removed type is not isomorphic to code_removed, because the code_removed constraint allows us to implement the code_removed function that allows us to distinguish between different code_removeds that produce the same string. a richer version of this idea can be seen in this \"shape example\" gist.", "when you \"borrow\" the do notation in the answer, it could be useful to say that it is actually valid syntax with the code_removed extension. a mention of other required extensions would be nice, like the aforementioned code_removed", "i'll add on to what leftaroundabout said. this is not really a potential concern for the list type, but in general, data types sometimes get modified. if you have an ill-conceived code_removed and later you learn to like code_removed and add it to the list, all your functions that pattern match on the type will need to be expanded. if you've used any code_removed patterns, you will need to find them manually; the compiler can't help you. if you've matched each thing explicitly, you can turn on code_removed and ghc will tell you about every spot you've missed.", "this can cover a really wide variety of different techniques. the simplest is basically unavoidable: if you want a value that can be null, that can depend on mutable state or user input, you have to mark that with the type system. this is what code_removed, code_removed and code_removed do respectively. so if you have something not in one of the three types above, you know it has to be a referentially transparent value that cannot be null. the techniques above are very fundamental to the language and basically unavoidable. however, there are other ways to use the type system to improve security and correctness that are a bit more interesting. one useful example is preventing sql injection. sql injection is a common problem in web applications--for the basic idea, check out this xkcd cartoon. we can actually use the type system to ensure that any string passed to the database has been sanitized. the basic idea is to create a new type for \"raw\" strings: code_removed then, make sure that all your functions for getting input from the user return code_removed values instead of normal strings. finally, you just need a sanitization function: code_removed since normal functions accept code_removed rather than code_removed, you will not be able to accidentally pass in an unsanitized string. and since we defined code_removed using code_removed, it has no runtime overhead at all. yesod, one of the main haskell web frameworks, uses a technique something like this to prevent sql injection. it also has some other cool approaches like using the type system to prevent broken links within your database; you should check it out. at the really extreme end, you can even use the type system to ensure that matrices are of the right size. here's a very simple way to do this. first, we need type-level numbers: code_removed (we're using peano arithmetic at the type level here.) the idea is simple: code_removed is 0 and code_removed is the successor function, so code_removed is 1, code_removed is 2 and so on. we can now write a safe matrix multiply function: code_removed this function will only let you multiply the matrices if the inner dimension matches, and ensures that the resulting matrix has the right dimensions in its type. type-safe matrix multiplication has more details.", "@captainobvious: 1 + 2 is neither nf nor whnf. expressions aren't always in a normal form.", "ghc also gives an option to code_removed a type-class instance declaration. i tried this with the (expanded) code of code_removed, by putting the following: code_removed this change, though, did not achieve the desired speedup. what did achieve that performance improvement was manually adding a specialized instance for the type code_removed with the same function definitions, as follows: code_removed this requires adding code_removed and code_removed in code_removed. interestingly, in the example program, the speedup obtained with the overlapping instance remains even if you remove every code_removed and code_removed pragma.", "@ganeshsittampalam ohhhh i see what you mean, i crashed into that wall of higher-kindedness. but you realize that posing things like this is a little silly because you are in oop, so actually the code_removed in code_removed of code_removed is the known by the actual object, and that code_removed is actually going to be a code_removed, so you can reduce this to code_removed.", "@sclv it is the question that is too broad (not opinion-based, etc.). an answer to too broad a question is necessarily too narrow.:)", "i think this doesn't handle symlinks properly. it should recreate them. see system.posix.files.", "@benmillwood other solutions, what?", "as far as the computer language benchmarks game goes java 7 has pulled out ahead of haskell. i remember haskell doing much better a couple of years ago. does this indicate a possible performance regression in ghc 7?", "this program produces the output i expect when given an input file of text delimited by n: code_removed by substituting withfile for openfile and rearranging slightly code_removed i manage to get no output at all. i'm stumped. edit: not stumped anymore: thanks to one and all for the thoughtful and thought-provoking answers. i did a little more reading in the documentation and learned that withfile can be understood as a partial application of bracket. this is what i ended up with: code_removed", "haskell does it this way because it's predecessors (like lml and miranda) did. there is no technical reason it has to be like this; equations with fewer arguments could be eta expanded. but having a different number of arguments for different equations is probably a typo rather than intentional, so in this case we ban something sensible&rare to get better error reporting in the common case.", "\"...conform to the structure of something called a monad in category theory, which is an obscure branch of mathematics.\" why exactly is it \"obscure\"? because the concepts are only 70 years old and never made it into school curricula so that people generally know about it? once you invest a few days in learning about natural transformations - two parts (return and join) of the triple which make up a monad - you see that they are indeed the nice and natural ones, amongst all functions. meanwhile, the mp3 format, an usb stick, or the term \"foobar\" are pretty ad hoc and not natural. \"man made\"", "so what do you do if you don't want seeds, because you want a hardware rng instead?", "this function: code_removed works fine. but this one: code_removed can't be compiled: \"could not deduce (eq a) arising from the literal `1'\" i really don't get it. i am reading a tutorial where it is said \"integral is also a numeric typeclass. num includes all numbers, including real numbers and integral numbers, integral includes only integral (whole) numbers. in this typeclass are int and integer.\" why can't i use num?", "@dave how can i import and use the split package, then?", "@luqui can you give a more detailed explanation maybe in an answer? i don't know about coproducts.", "code_removed notation is just a syntactic sugar. it can be avoided in all cases. however, in some cases replacing code_removed with code_removed and code_removed makes code less readable. so, for your questions: \"shall we avoid the do statement in any case?\". focus on making your code clear and better readable. use code_removed when it helps, avoid it otherwise. and i had another question, why most tutorials will teach io with do? because code_removed makes io code better readable in many cases. also, the majority of people who starts learning haskell have imperative programming experience. tutorials are for beginners. they should use style that is easy to understand by newcomers.", "it's a strictness declaration. basically, it means that it must be evaluated to what's called \"weak normal head form\" when the data structure value is created. let's look at an example, so that we can see just what this means: code_removed the function code_removed above, when evaluated, will return a \"thunk\": that is, the code to execute to figure out its value. at that point, a foo doesn't even exist yet, just the code. but at some point someone may try to look inside it, probably through a pattern match: code_removed this is going to execute enough code to do what it needs, and no more. so it will create a foo with four parameters (because you can't look inside it without it existing). the first, since we're testing it, we need to evaluate all the way to code_removed, where we realize it doesn't match. the second doesn't need to be evaluated, because we're not testing it. thus, rather than code_removed being stored in that memory location, we'll just store the code for possible later evaluation, code_removed. that will turn into a 6 only if someone looks at it. the third parameter, however, has a code_removed in front of it, so is strictly evaluated: code_removed is executed, and code_removed is stored in that memory location. the fourth parameter is also strictly evaluated. but here's where it gets a bit tricky: we're evaluating not fully, but only to weak normal head form. this means that we figure out whether it's code_removed or code_removed something, and store that, but we go no further. that means that we store not code_removed but actually code_removed, leaving the thunk inside unevaluated. this is important to know, though i think that all the implications of this go rather beyond the scope of this question. you can annotate function arguments in the same way, if you enable the code_removed language extension: code_removed code_removed will return the thunk code_removed.", "how can there be more than two levels of definedness (i.e. defined and undefined)?", "(surely this is a duplicate question, but i can't find one now.) you learn it in order to learn pure functional programming, which forces you to do many things in a completely different way. you get a new way of thinking. programming without state? programming without effects? everything is lazy? crazy type system with type inference? what the hell are monads? your mind will be repeatedly blown, but in the end you come out with new perspectives/techniques from functional programming that are hard to otherwise pick up without going full-blown haskell. the problem with trying to be specific, is that trying to tell a non-haskeller what they'll learn from haskell is like trying to explain the color \"green\" to a blind guy.", "it should be noted that you get a similar effect by using the lift functions, e.g.: code_removed or, using the monad instance of ((->) r) instead of the applicative one: code_removed [digression] now that you know how to distribute one argument to two intermediate functions and the result to a binary function, there is the somehow related case that you want to distribute two arguments to one intermediate function and the results to a binary function: code_removed this pattern is e.g. often used for the code_removed function.", "@akshay compare the performance of code_removed with the performance of code_removed.;-) (spoilers: code_removed is the right one, not code_removed.)", "question 1: do erlang, python and haskell loose speed due to using arbitrary length integers or don't they as long as the values are less than maxint? this is unlikely. i cannot say much about erlang and haskell (well, maybe a bit about haskell below) but i can point a lot of other bottlenecks in python. every time the program tries to execute an operation with some values in python, it should verify whether the values are from the proper type, and it costs a bit of time. your code_removed function just allocates a list with code_removed various times, and runtime, code_removed-styled memory allocation is way slower than iterating on a range with a counter as you do in c. notably, the code_removed is called multiple times and so allocates a lot of lists. also, let us not forget that python is interpreted and the cpython interpreter has no great focus on being optimized. edit: oh, well, i note that you are using python 3 so code_removed does not return a list, but a generator. in this case, my point about allocating lists is half-wrong: the function just allocates code_removed objects, which are inefficient nonetheless but not as inefficient as allocating a list with a lot of items. question 2: why is haskell so slow? is there a compiler flag that turns off the brakes or is it my implementation? (the latter is quite probable as haskell is a book with seven seals to me.) are you using hugs? hugs is a considerably slow interpreter. if you are using it, maybe you can get a better time with ghc - but i am only cogitating hypotesis, the kind of stuff a good haskell compiler does under the hood is pretty fascinating and way beyond my comprehension:) question 3: can you offer me some hints how to optimize these implementations without changing the way i determine the factors? optimization in any way: nicer, faster, more \"native\" to the language. i'd say you are playing an unfunny game. the best part of knowing various languages is to use them the most different way possible:) but i digress, i just do not have any recommendation for this point. sorry, i hope someone can help you in this case:) question 4: do my functional implementations permit lco and hence avoid adding unnecessary frames onto the call stack? as far as i remember, you just need to make sure that your recursive call is the last command before returning a value. in other words, a function like the one below could use such optimization: code_removed however, you would not have such optimization if your function were such as the one below, because there is an operation (multiplication) after the recursive call: code_removed i separated the operations in some local variables for make it clear which operations are executed. however, the most usual is to see these functions as below, but they are equivalent for the point i am making: code_removed note that it is up to the compiler/interpreter to decide if it will make tail recursion. for example, the python interpreter does not do it if i remember well (i used python in my example only because of its fluent syntax). anyway, if you find strange stuff such as factorial functions with two parameters (and one of the parameters has names such as code_removed, code_removed etc.) now you know why people do it:)", "thank you for the answer and for the link. i suppose rejected proposal are to be avoided.", "ghc will do run-time linker detection soon (probably 7.8): hackage.haskell.org/trac/ghc/ticket/6063#comment:19", "i have been using haskell for quite a while. the more i use it, the more i fall in love with the language. i simply cannot believe i have spent almost 15 years of my life using other languages. however, i am slowly but steadily growing fed up with haskell's standard libraries. my main pet peeve is the \"not polymorphic enough\" definitions (code_removed, code_removed, etc.). i have a lot of haskell source code files whose first lines look like code_removed in order to avoid constantly hoogling which definitions i should hide, i would like to have a single or a small amount of source code files that wrap this code_removed boilerplate into manageable units. so... has anyone else tried doing this before? if the answer to the previous question is \"yes\", have they posted the resulting boilerplate-wrapping source code files?", "to precisely understand the meaning of polymorphism, i find it convenient to think about functional languages with explicit type arguments -- either theoretical ones, such as system f, or real-world ones such as agda, idris, coq, etc. in these languages, types are passed as function arguments as values normally are. if we have a polymorphic function code_removed this actually expects a type as a first argument, like this: code_removed note how the code_removed in the resulting type gets instantiated to the type argument. adding typeclass constraints, we have that code_removed can be seen as a function expecting: 1) a type argument code_removed, 2) a proof that the chosen type is a code_removed (e.g. a typeclass dictionary). when this is provided, a result of the chosen type code_removed will be returned. a more pedantic definition could be code_removed where code_removed is used as a type-level lambda, for the additional arguments described earlier. a call could then be as follows: code_removed which will return code_removed. now, what happens if we write the posted code? code_removed well, now code_removed and code_removed expect type arguments, as well as code_removed, since all three are polymorphic values. during type inference, a few additional arguments are added by the compiler as follows: code_removed (technically, even code_removed, being polymorphic, has additional arguments, but let's put that under the rug for readability's sake...) note that now it is clear what type code_removed should produce: it's code_removed, the same type which is produced by code_removed. in other words, code_removed asks its caller which type is wanted, and forwards the same type to code_removed. ditto for code_removed. by comparison, in code_removed there's no polymorphism in code_removed, but code_removed and code_removed are still polymorphic. during type inference the compiler reaches code_removed and has to invent code_removed and code_removed out of thin air, since code_removed is not asking them to its caller. hence the ambiguity error. finally, note that it is possible to see the additional type arguments which are added by ghc during type inference. to do that, it suffices to dump the ghc core intermediate language, e.g. with the code_removed ghc flag. in ghc 8.x, which is not yet released, rumors say that we will be even allowed to specify explicit type arguments in our code when we want to, and let the compiler infer them as usual otherwise. it sounds fun!", "this answer explains, why we need the monad typeclass. the best way to understand, why we need monads and not something else, is to read about difference between monads and applicative functors: one, two.", "code_removed and code_removed don't really belong under the heading 'numbers'. has anybody a good idea under what heading(s) they could be subsumed?", "basically, your code_removed function takes a code_removed argument. only upon execution is it passed in.", "doesn't work either: src/main.hs:12:3: no instance for (printfarg text) arising from a use of 'printt' possible fix: add an instance declaration for (printfarg text) in a stmt of a 'do' block: printt \"input: %s\" input in the expression: do { let input:: text = \"abc\"; printt \"input: %s\" input } in an equation for 'main': main = do { let input:: text =...; printt \"input: %s\" input }", "@dan, indeed, there is provably no such algorithm (as long as you are using only element-element comparison; contrast radix sort)", "hey just coming back to let you know this is a brilliant answer in most aspects, thank you.", "0 was once not considered to be a number. \"how can nothing be something?\" but over time we came to accept 0 as a number, noticing its properties and its usefulness. today the idea that 0 is not a number is as absurd as the idea that it was one 2,000 years ago. code_removed is a type the same way 0 is a number. its kind is code_removed, just like all other types. the similarity between code_removed and 0 runs quite deep, as tikhon jelvis's answer begins to show. there is a strong mathematical analogy between types and numbers, with code_removed playing the role of addition, tupling code_removed playing the role of multiplication, functions code_removed) as exponentiation (code_removed means ba), code_removed (pronounced \"unit\") as 1, and code_removed as 0. the number of values a type may take is the numeric interpretation of the type. so code_removed is interpreted as code_removed so we should expect three values. and indeed there are exactly three. code_removed similarly, code_removed is interpreted as code_removed so we should expect four values. can you list them? coming back to code_removed, you can have, say, code_removed, which would be interpreted as 1 + 0. the constructors of this type are code_removed, and code_removed for every value code_removed of type code_removed -- however there are no values of type code_removed, so the only constructor for code_removed is code_removed. and 1 + 0 = 1, so we got what we expected. exercise: what should the mathematical interpretation of code_removed be? how many values of code_removed are there -- does this fit with the interpretation? notes i am ignoring partiality in this treatment, pretending haskell is total. technically code_removed can have type code_removed, but we like to use fast and loose reasoning which ignores these. the way code_removed is used in c-based languages is actually much more like haskell's code_removed than haskell's code_removed. in haskell, a function returning code_removed can never return at all, whereas in code_removed languages a function returning code_removed can return, but the return value is uninteresting -- there's only one thing it could be so why bother?", "what is a categorical return type exactly? code_removed seems to form a category whose objects are haskell types and such that the arrows from code_removed to code_removed are the functions from code_removed to code_removed, with code_removed and code_removed. is that about right, or am i mixing up different levels of things or something?", "@michaelfox statically linking the ghc api doesn't work with the new dynamic linker introduced in ghc 7.8, i think:| (interactive code execution now requires dynamic libraries)", "how do you really prove that there is no code_removed instance? your argument \"there is no natural way of implementing code_removed when a function code_removed could return code_removed or code_removed for different values of code_removed\" works for code_removed as well.", "for comparison i get 9.03 with the original c version while using erlang 19 with mark's code i get 5.406, 167.0366% faster.", "there is an abundance of priority queue implementations to be found on hackage, just to complete your list: out of those i found that psqueue has an especially nice interface. i guess it was one of the first implementations and is nicely covered in this paper by ralf hinze. it might not be the most efficient and complete implementation but so far it has served all my needs. there is a very good article in the monadreader (issue 16) by louis wassermann (who also wrote the pqueue package). in his article louis gives a variety of different priority queue implementations and also includes algorithmic complexities for each. as a striking example of the simplicity of some priority queue internals he includes some cool little implementations. my favorite one (taken from his article): code_removed cool little implementation...a short usage example: code_removed some benchmarks of priority queue implementations can be found here and in a rather interesting thread on haskell.org here.", "i think the general answer should come from source->source transformations, since loading specially compiled shared objects seems to be a bit of a kludge (involving ghc->c and a c->java step in the answers above). this question thus falls under the heading of haskell on the jvm, which has been tried (with one step as a java intermediate representation) and discussed at length. you could use frege if the libraries you need compile there. the only remaining steps would be the beginnings of the android framework api translated into io() actions and maybe a wrapper for building the manifest xml and apk.", "i wrote a bit about this under \"design guidelines\" in this document: community.haskell.org/~ndm/downloads/\u2026", "here's a version, just to prove you can convert code from wikipedia almost exactly into haskell;) code_removed", "i'm not sure if this actualy beats rolling your own in all cases. it's sounds like the op uses this a lot, but if this was a small thing i wouldn't want to pull in dependencies on profunctors, mtl, semigroups etc", "@danielwagner, the implicit sharing would have to become explicit, with each component of the type named. i guess the ghc developers don't want to deal with that headache.", "with the new polykinded code_removed you no longer need code_removed.", "your point-free code_removed would still be hard to penetrate if it used the more readable code_removed and code_removed (resp. 2) instead of code_removed and code_removed (honestly, anybody who uses that must be a tool, hopefully a command-line tool). well-reasoned answer.", "@dietrichepp i don't follow what you are saying. can you point to a specific example code for the multidimensional array? also i don't see how it helps to look at code_removed as tensor product. i'd rather agree that the monoidal operation code_removed is similar to a tensor product. but i still don't see how this helps to verify that tensor arrays have no monad instance.", "your answer is right in the sense that monads imo indeed are best described as being about the composition/ality of \"functions\" (kleisli arrows really), but the precise details of what type goes where are what makes them \"monads\". you could wire the boxes in all kinds of manners (like functor, etc.). this specific way of wiring them together is what defines \"the monad\".", "with functors and coproducts you can just view this as an \"hlist1\". it's just the usual trick of having a type level representation of the value level list. it can be made a lot prettier with gadts + datakinds to promote a proper list to type level", "about google and non-alphanumerical: it's hard to do a search in google about \"google+\" for the same reason. funny.", "thanks, great answer. your mention of code_removed makes it more intuitive to understand and i'm glad you didn't left it out. it will take my brain a few more days to fully understand your answer.", "but be careful; if the list generation isn't as nice, garbage collection may be prevented. consider code_removed, each list element refers to the previous, so nothing can be collected immediately.", "@sassanf you mean a feature has been recently added that would answer my main question? could you provide a link so i can read up on it?", "dupe? stackoverflow.com/questions/775726/whats-the-fuss-about-hask\u200c\u200bell", "pivoting off some recent questions, i figured i'd turn the spotlight on the old bogeyman, code_removed. a few years ago i might've been asking this question in earnest: after all, you can provide useful default instances and others can override them with more specific ones when they need to, what can be so bad about that? along the way i've absorbed some apprecation for the viewpoint that code_removed is really not so clean, and best avoided; mainly stemming from the fact that it's not very well-grounded theoretically, unlike other big extensions. but thinking about it, i'm not sure if i could explain what's really so bad about it to another person, if i were asked. what i'm looking for is specific examples of ways in which using code_removed can lead to bad things happening, whether it's by subverting the type system or other invariants, or just general unexpectedness or messiness. one particular problem i know of is that it breaks the property that merely adding or removing a single module import can't change the meaning of your program, because with the extension on, a new instance overlap could be silently added or removed. while i can see why that's unpleasant, i don't see why it's earth-shatteringly awful. bonus question: as long as we're on the subject of useful but not theoretically well-grounded extensions that can lead to bad happenings, how come code_removed doesn't get the same bad rap? is it because the negative possibilities are more easy to localize; that it's easier to see what would cause problems and say, \"don't do that\"? (note: i would prefer if the brunt of the answer focuses on code_removed, not code_removed which needs less explanation.) edit: there are also good answers to a similar question here.", "@donstewart, may \"it binds types to some scope\" better phrased as \"it binds type variables to some scope\" in your explanation?", "no, not on linux. it only depends on gcc. because windows has no gcc in its \"distribution\", it has to come with ghc.", "@stephen, could you write down the definition of the other implementation of the rose tree you are referring to?", "@cmcdragonkai: yes, code_removed would also work."]