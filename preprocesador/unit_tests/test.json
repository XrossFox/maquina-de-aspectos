["<p>I have two Python dictionaries, and I want to write a single expression that returns these two dictionaries, merged.  The <code>update()</code> method would be what I need, if it returned its result instead of modifying a dict in-place.</p>\n\n<pre><code>&gt;&gt;&gt; x = {'a':1, 'b': 2}\n&gt;&gt;&gt; y = {'b':10, 'c': 11}\n&gt;&gt;&gt; z = x.update(y)\n&gt;&gt;&gt; print(z)\nNone\n&gt;&gt;&gt; x\n{'a': 1, 'b': 10, 'c': 11}\n</code></pre>\n\n<p>How can I get that final merged dict in <code>z</code>, not <code>x</code>?</p>\n\n<p>(To be extra-clear, the last-one-wins conflict-handling of <code>dict.update()</code> is what I'm looking for as well.)</p>\n", "@Alex sometimes the original question isn&#39;t the right question. If you need to use a non-pythonic monster of a regular expression, for instance, to do something in one line, or two elegent lines. to do X, then use the two lines. The <code>{**x, **y}</code> approach in the accepted answer is a monstrosity.", "<p>This probably won't be a popular answer, but you almost certainly do not want to do this.  If you want a copy that's a merge, then use copy (or <a href=\"https://docs.python.org/2/library/copy.html\" rel=\"noreferrer\">deepcopy</a>, depending on what you want) and then update.  The two lines of code are much more readable - more Pythonic - than the single line creation with .items() + .items().  Explicit is better than implicit.</p>\n\n<p>In addition, when you use .items() (pre Python 3.0), you're creating a new list that contains the items from the dict.  If your dictionaries are large, then that is quite a lot of overhead (two large lists that will be thrown away as soon as the merged dict is created).  update() can work more efficiently, because it can run through the second dict item-by-item.</p>\n\n<p>In terms of <a href=\"https://docs.python.org/2/library/timeit.html\" rel=\"noreferrer\">time</a>:</p>\n\n<pre><code>&gt;&gt;&gt; timeit.Timer(\"dict(x, **y)\", \"x = dict(zip(range(1000), range(1000)))\\ny=dict(zip(range(1000,2000), range(1000,2000)))\").timeit(100000)\n15.52571702003479\n&gt;&gt;&gt; timeit.Timer(\"temp = x.copy()\\ntemp.update(y)\", \"x = dict(zip(range(1000), range(1000)))\\ny=dict(zip(range(1000,2000), range(1000,2000)))\").timeit(100000)\n15.694622993469238\n&gt;&gt;&gt; timeit.Timer(\"dict(x.items() + y.items())\", \"x = dict(zip(range(1000), range(1000)))\\ny=dict(zip(range(1000,2000), range(1000,2000)))\").timeit(100000)\n41.484580039978027\n</code></pre>\n\n<p>IMO the tiny slowdown between the first two is worth it for the readability.  In addition, keyword arguments for dictionary creation was only added in Python 2.3, whereas copy() and update() will work in older versions.</p>\n", "but it&#39;s three statements rather than one expression", "<h1>Recursively/deep update a dict</h1>\n\n<pre><code>def deepupdate(original, update):\n    \"\"\"\n    Recursively update a dict.\n    Subdict's won't be overwritten but also updated.\n    \"\"\"\n    for key, value in original.iteritems(): \n        if key not in update:\n            update[key] = value\n        elif isinstance(value, dict):\n            deepupdate(value, update[key]) \n    return update</code></pre>\n\n<p>Demonstration:</p>\n\n<pre><code>pluto_original = {\n    'name': 'Pluto',\n    'details': {\n        'tail': True,\n        'color': 'orange'\n    }\n}\n\npluto_update = {\n    'name': 'Pluutoo',\n    'details': {\n        'color': 'blue'\n    }\n}\n\nprint deepupdate(pluto_original, pluto_update)</code></pre>\n\n<p>Outputs:</p>\n\n<pre><code>{\n    'name': 'Pluutoo',\n    'details': {\n        'color': 'blue',\n        'tail': True\n    }\n}</code></pre>\n\n<p>Thanks rednaw for edits.</p>\n", "<p>In Python 3, you can use <a href=\"http://docs.python.org/3/library/collections.html#collections.ChainMap\"><em>collections.ChainMap</em></a> which groups multiple dicts or other mappings together to create a single, updateable view:</p>\n\n<pre><code>&gt;&gt;&gt; from collections import ChainMap\n&gt;&gt;&gt; x = {'a':1, 'b': 2}\n&gt;&gt;&gt; y = {'b':10, 'c': 11}\n&gt;&gt;&gt; z = ChainMap({}, y, x)\n&gt;&gt;&gt; for k, v in z.items():\n        print(k, '--&gt;', v)\n\na --&gt; 1\nb --&gt; 10\nc --&gt; 11\n</code></pre>\n", "Actually, the kind of output you have got here can be achieved even without using <code>ChainMap</code> right? I mean, all you have to do is just update <code>z = {**x, **y}</code> and follow the traditional steps, that&#39;s it!", "<p>Abuse leading to a one-expression solution for <a href=\"https://stackoverflow.com/a/39437/15055\">Matthew's answer</a>:</p>\n\n<pre><code>&gt;&gt;&gt; x = {'a':1, 'b': 2}\n&gt;&gt;&gt; y = {'b':10, 'c': 11}\n&gt;&gt;&gt; z = (lambda f=x.copy(): (f.update(y), f)[1])()\n&gt;&gt;&gt; z\n{'a': 1, 'c': 11, 'b': 10}\n</code></pre>\n\n<p>You said you wanted one expression, so I abused <code>lambda</code> to bind a name, and tuples to override lambda's one-expression limit. Feel free to cringe.</p>\n\n<p>You could also do this of course if you don't care about copying it:</p>\n\n<pre><code>&gt;&gt;&gt; x = {'a':1, 'b': 2}\n&gt;&gt;&gt; y = {'b':10, 'c': 11}\n&gt;&gt;&gt; z = (x.update(y), x)[1]\n&gt;&gt;&gt; z\n{'a': 1, 'b': 10, 'c': 11}\n</code></pre>\n", "You might be interested in <code>cytoolz.merge_with</code> (<a href=\"https://toolz.readthedocs.io/en/latest/api.html#toolz.dicttoolz.merge_with\" rel=\"nofollow noreferrer\">toolz.readthedocs.io/en/latest/&hellip;</a>)", "<p>It's so silly that <code>.update</code> returns nothing.<br>\nI just use a simple helper function to solve the problem:</p>\n\n<pre><code>def merge(dict1,*dicts):\n    for dict2 in dicts:\n        dict1.update(dict2)\n    return dict1\n</code></pre>\n\n<p>Examples:</p>\n\n<pre><code>merge(dict1,dict2)\nmerge(dict1,dict2,dict3)\nmerge(dict1,dict2,dict3,dict4)\nmerge({},dict1,dict2)  # this one returns a new copy\n</code></pre>\n"]